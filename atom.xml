<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dumeng&#39;s Blog</title>
  
  <subtitle>writedown everything</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dumengblog.club/"/>
  <updated>2020-02-05T08:51:29.913Z</updated>
  <id>http://dumengblog.club/</id>
  
  <author>
    <name>dumeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySql数据库存储引擎MyISAM与InnoDB</title>
    <link href="http://dumengblog.club/2020/02/05/MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E4%B8%8EInnoDB/"/>
    <id>http://dumengblog.club/2020/02/05/MySql数据库存储引擎MyISAM与InnoDB/</id>
    <published>2020-02-05T08:45:14.000Z</published>
    <updated>2020-02-05T08:51:29.913Z</updated>
    
    <content type="html"><![CDATA[<p>MySql可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。而每一种存储引擎也使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。常见的存储引擎有MyISAM，InnoDB，Memory，Archive等。</p><a id="more"></a>　　<p>本文主要介绍的是：MyISAM与InnoDB。在5.5版本之前，MyISAM是MySQL的默认数据库引擎。虽然性能极佳，但却有一个缺点：不支持事务处理。在之后，MySql的默认数据库引擎就是InnoDB了。与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，以及外部键等高级数据库功能。下面就主要聊聊这两者的具体区别。<br>MyISAM与InnoDB的区别<br>存储结构</p><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">table_name.frm      存储表结构（定义）。</span><br><span class="line">table_name.MYD      存储数据</span><br><span class="line">table_name.MYI      存储索引文件</span><br></pre></td></tr></table></figure><p>InnoDB：把数据存储在表空间中，分为两种方式：<br>　　1）、所有InonoDB表的数据和索引放置于同一个表空间中；<br>　　2）、每个表单独使用一个表空间存储表的数据和索引。<br>当所有表位于同一表空间中，其数据文件存于数据目录下以ibddata[#]来命名。这种方式不利于管理和备份恢复。所以一般使用第二种方式，每张表创建单独的表空间，用来实现InnoDB所支持的高级特性，比如单表导入导出，单标备份等功能。数据文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table_name.ibd     存储数据和索引</span><br><span class="line">table_name.frm     存储表结构（定义）</span><br></pre></td></tr></table></figure><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>MyISAM：强调性能，其执行速度比InnoDB类型更快但不提供事务的支持，也不支持外键，适用于大量select操作的应用场景。</p><p>InnoDB：支持事务，并把事务分为四个隔离级别，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">READ-UNCOMMITTED：   读未提交容易发生脏读；</span><br><span class="line">READ-COMMITTED：     读提交，该级别不可重复读；</span><br><span class="line">REPEATABLE-READ：    可重复读，该级别容易发生幻读；</span><br><span class="line">SERIALIZABLE：       串行化；</span><br></pre></td></tr></table></figure><p>默认级别为REPEATABLE-READ。适合对事务要求较高的场景中，较适用于处理大量短期事务。<br>同时，InnoDB也支持外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。<br>锁粒度</p><p>MyISAM：只支持表锁。，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持行锁，极大提升并发能力，并使用间隙锁来防止幻读。当然InnoDB的行级锁也并非绝对，当SQL语句在执行过程中在不能确定扫描范围时也会对整张表进行锁定（只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的）。<br>索引类型</p><p>MyISAM：非聚集索引并且支持全文索引（fulltext index）。允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：聚集索引，辅助索引，可以使用sphinx插件支持全文索引。如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值的数据列。<br>AUTO_INCREMENT</p><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。<br>存储空间</p><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认)、动态表、压缩表。<br>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。<br>备份及恢复策略</p><p>MyISAM：只支持温备与冷备。崩溃后无法安全恢复。<br>InnoDB：支持热备、温备、冷备。崩溃后可安全恢复。<br>其他</p><p>　　１）、MyISAM保存有表的总行数，如果select count() from table;会直接取出出该值。InnoDB没有保存表的总行数，如果使用select count() from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。<br>　　２）、MyISAM不支持外键；而InnoDB支持外键。<br>　　３）、MyISAM不支持hash索引；InnoDB支持自适应的hash索引，使用MVCC来支持高并发。<br>查看与修改数据库引擎<br>查看数据库引擎</p><pre><code>show create table table_name;</code></pre><p>修改表的存储引擎</p><p>1、修改mysql的配置文件</p><pre><code>default-storage-engine = engine_name</code></pre><p>2、通过创建表的命令实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">......</span><br><span class="line">)<span class="keyword">engine</span> = engine_name;</span><br></pre></td></tr></table></figure><p>3、表单创建完成后，通过修改数据表命令实现</p><p>alter table table_name engine = engine_name;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">engine</span> = engine_name;</span><br></pre></td></tr></table></figure><p>MyISAM和InnoDB的选择</p><p>　　数据库引擎的选择需要我们根据实际情况来选择。默认的InnoDB已经足够使用。<br>　　（1）、当项目中需要事务处理或是外键，那么应该使用InnoDB 。如果你需要全文索引，那么通常来说 MyISAM是好的选择，因为这是系统内建的，但是，我们其实并不会经常地去海量记录。所以，就算是慢一点，我们可以通过使用Sphinx从InnoDB中获得全文索引。<br>　　（２）、数据的大小，同样是一个影响你选择什么样存储引擎的重要因素，大尺寸的数据集趋向于选择InnoDB方式，因为其支持事务处理和故障恢复。数据库的在小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。而MyISAM可能会需要几个小时甚至几天来干这些事，InnoDB只需要几分钟。<br>　　（3）、当并发量不大的时候，大批的insert语句或select语句在MyISAM下会快一些，因为MyISAM提供高速存储和检索，以及全文搜索能力。但是当并发量大的时候，在用InnoDB就比MyISAM效率高多了。因为MyISAM只支持表锁，而InnoDB支持效率更高的行锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySql可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。而每一种存储引擎也使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。常见的存储引擎有MyISAM，InnoDB，Memory，Archive等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://dumengblog.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库索引</title>
    <link href="http://dumengblog.club/2020/02/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>http://dumengblog.club/2020/02/05/数据库索引/</id>
    <published>2020-02-05T05:36:58.000Z</published>
    <updated>2020-02-05T08:54:40.702Z</updated>
    
    <content type="html"><![CDATA[<p>首先推荐一个学习数据结构的网站</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><a id="more"></a><h4 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h4><p><strong>索引</strong>是帮助MySQL高效获取数据的<strong>排好序</strong>的<strong>数据结构</strong></p><h4 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h4><ol><li>二叉排序树</li><li>红黑树</li><li>Hash表</li><li>B-Tree（数据库用的）</li></ol><p>在这里说一下为什么不用二叉树，如果你的数据是排序过的例如1，2，3，4，5，6</p><p>那么插入到二叉树情况如图：</p><img src="/../asset/image-20200205140704841.png" alt="image-20200205140704841" style="zoom: 67%;"> <p>很明显这样是根本无法帮助你快速查询。</p><p>至于红黑树， 是一种自平衡二叉搜索树，接下来我会用图片演示，</p><p><img src="/../asset/image-20200205141052833.png" alt="image-20200205141052833" style="zoom:67%;"> <img src="/../asset/image-20200205141113339.png" alt="image-20200205141113339" style="zoom:67%;"></p><img src="/../asset/image-20200205141211728.png" alt="image-20200205141211728" style="zoom:67%;"> <p>就像图片那样，当你一边子树过多时，他就会自动调整，但是如果数据过多还会存在问题，那就是树的深度太大，查找也会费时间</p><p>在这里我们引入B树。</p><img src="/../asset/image-20200205155229281.png" alt="image-20200205155229281" style="zoom:67%;"> <ol><li>叶节点具有相同的深度，叶节点的指针为空</li><li>所有索引元素不重复</li><li>节点中的数据索引从左到右依次递增排列</li></ol><p>但在数据库中实际用到的是B+树，根据B树更改的一种数据结构</p> <img src="/../asset/7862980-42f0acde88d3c0cb.png" alt="img" style="zoom:67%;"> <p><strong>B+树特征</strong></p><ol><li><p>非叶子结点不存储data，只存储索引（冗余），可以放更多的索引</p></li><li><p>叶子结点包含所有索引字段</p></li><li><p>叶子结点用指针连接，提高区间访问性能</p></li></ol><p>具体请访问<a href="https://www.jianshu.com/p/71700a464e97" target="_blank" rel="noopener">https://www.jianshu.com/p/71700a464e97</a></p><h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>在理想的情况下，key非常分散，不存在Hash碰撞的话，采用Hash索引可以唯一得确定一个key的位置，并且这个位置上就只有一个key，所以查找时间复杂度是O（1），非常快，这是Hash索引的最主要优势。但是呢，Hash索引不是没有缺点，不存在Hash碰撞这是理想情况，通常情况下，同一个Hash值都不只有一个key，也就是说你根据一个key找到了他的hash值位置之后，但是这个位置还有别的key，所以你还得从这个位置找到真正的key，至于怎么找，这个和具体的hash碰撞处理方式有关，最常用的扩展链表法，就是在hash位置上放置链表，此时，就存在一个链表查询的过程，如果hash碰撞比较严重，查询的时间复杂度就远不止O(1)，那么hash索引的优势就失去了。其次，Hash索引是不排序的，因此它只适用于等值查询，如果你要查询一定的范围内的数据，那么hash索引是无能为力的，只能把数据挨个查，而不能仅仅是查询到头尾数据之后，从头读到位。并且，hash索引也无法根据索引完成排序，这也是它的不足之一。</p><p>而B+树是一颗严格平衡搜索的树，从根节点到达每一个叶子节点的路径长度都是一样的，并且每个节点可以有多个孩子节点（高扇出），所以可以进可能的把树的高度降到很低。这么做的好处是可以降低读取节点的次数，这就是的B+树非常适合做外部文件索引了。在外部文件索引中，必须要读取到一个节点之后，才能知道它所有的孩子几点的位置，而读取一个节点对应一次IO，所以读取叶子节点的IO数就等于树的高度了，因此树的高度越低，所需要的IO次数就越少。B+树是一颗搜索树，所有的数据都放在叶子节点上，并且这些数据是按顺序排列的。所以在范围查询中，只需要找到范围的上下界节点，就可以得到整个范围内的数据，而且还有一个好处，由于这些数据都是排好序的，所以无需对数据进行再次排序。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1.Hash索引在不存在hash碰撞的情况下，之需一次读取，查询复杂度为O（1），比B+树快。</p><p>2.但是Hash索引是无序的，所以只适用于等值查询，而不能用于范围查询，自然也不具备排序性。根据hash索引查询出来的数据，还有再次进行排序</p><p>3.B+树索引的复杂度等于树的高度，一般为3-5次IO。但是B+树叶子节点上的数据是排过序的，因此可以作用于范围查找，而且查询的数据是排过序的，无需再次排序。对于像“SELECT xxx FROM TABLE1 WHERE xxx LIKE ‘aaa%’”这样涉及到模糊匹配的查询，本质上也是范围查询。</p><p>4.还有一点，数据库中的多列索引中，只能用B+树索引。数据在B+树的哪个结点上，只取决于最左边的列上的key，在结点中在一次按照第二列、第三列排序。所以B+树索引有最左原则的特性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先推荐一个学习数据结构的网站&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据库" scheme="http://dumengblog.club/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>java的可见性，有序性，原子性</title>
    <link href="http://dumengblog.club/2020/02/02/java%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%8C%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    <id>http://dumengblog.club/2020/02/02/java的可见性，有序性，原子性/</id>
    <published>2020-02-02T05:19:17.000Z</published>
    <updated>2020-02-02T05:30:43.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><a id="more"></a><p> 可见性：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。 </p><p> 有序性：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。 </p><p> 原子性：一个操作不能被打断，要么全部执行完毕，要么不执行。 </p><h4 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2.实现方法"></a>2.实现方法</h4><p><strong>可见性：</strong></p><p>volatile关键字：<strong>通过volatile关键字修饰内存中的变量，该变量在线程之间共享</strong>，具体可以看我之前的博客：<a href="https://dumengblog.club/2020/02/01/volatile%E5%85%B3%E9%94%AE%E5%AD%97/#more">https://dumengblog.club/2020/02/01/volatile%E5%85%B3%E9%94%AE%E5%AD%97/#more</a></p><p><strong>原子性：</strong><br> java.util.concurrent.atomic，原子类了解一下？<br> 在java中，我们知道++操作实际上并不是线程安全的，为了保证线程间的变量原子性，java引入了atomic类。它的作用就是保证，使用的变量，一定是原子性的。<br> 代码咱看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomicCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Executors.newFixedThreadPool(<span class="number">3</span>).execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//atomicCount.incrementAndGet()方法的意思是让其自增 1，等同于++</span></span><br><span class="line">            System.out.println(<span class="string">"atomic count: "</span> + atomicCount.incrementAndGet());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有序性：</strong><br> synchronized，日常用的最多的东西，当使用synchronized关键字时，只能有一个线程执行直到执行完成后或异常，才会释放锁。所以可以保证synchronized代码块或方法只会有一个线程执行，保障了程序的有序性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1.定义&quot;&gt;&lt;/a&gt;1.定义&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="java基础" scheme="http://dumengblog.club/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>CAS是什么？</title>
    <link href="http://dumengblog.club/2020/02/02/CAS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://dumengblog.club/2020/02/02/CAS是什么？/</id>
    <published>2020-02-02T03:47:34.000Z</published>
    <updated>2020-02-02T05:18:01.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是CAS？"><a href="#1-什么是CAS？" class="headerlink" title="1.什么是CAS？"></a>1.什么是CAS？</h4><a id="more"></a><p>CAS,compare and swap的缩写，中文翻译成<strong>比较并交换</strong>。</p><p>我们都知道，在java语言之前，并发就已经广泛存在并在服务器领域得到了大量的应用。所以硬件厂商老早就在芯片中加入了大量直至并发操作的原语，从而在硬件层面提升效率。在intel的CPU中，使用cmpxchg指令。</p><p>在Java发展初期，java语言是不能够利用硬件提供的这些便利来提升系统的性能的。而随着java不断的发展,Java本地方法(JNI)的出现，使得java程序越过JVM直接调用本地方法提供了一种便捷的方式，因而java在并发的手段上也多了起来。而在Doug Lea提供的cucurenct包中，CAS理论是它实现整个java包的基石。</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。  如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS  指令之前返回该 位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前 值。）CAS 有效地说明了“我认为位置 V  应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”</p><p>通常将 CAS 用于同步的方式是从地址 V 读取值 A，执行多步计算来获得新 值 B，然后使用 CAS 将 V 的值从 A 改为 B。如果 V 处的值尚未同时更改，则 CAS 操作成功。</p><p>类似于 CAS 的指令允许算法执行读-修改-写操作，而无需害怕其他线程同时 修改变量，因为如果其他线程修改变量，那么 CAS 会检测它（并失败），算法 可以对该操作重新计算。</p><h4 id="2-简单操作"><a href="#2-简单操作" class="headerlink" title="2.简单操作"></a>2.简单操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDEMO</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AtomicInteger atomicInteger=<span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">2019</span>)+<span class="string">"\t current data:"</span>+atomicInteger.get());</span><br><span class="line"></span><br><span class="line">System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>, <span class="number">1024</span>)+<span class="string">"\t current data:"</span>+atomicInteger.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>true     current data:2019<br>false     current data:2019</p><p><img src="/../asset/image-20200202120608491.png" alt="image-20200202120608491"> </p><h4 id="3-CAS底层原理"><a href="#3-CAS底层原理" class="headerlink" title="3.CAS底层原理"></a>3.CAS底层原理</h4><p>CAS并发原语体现在java语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现CAS汇编指令。只是一种完全依赖与硬件的功能，通过它实现了原子操作，再次强调由于CAS属于一种系统原语，原语属于操作系统的范畴，是有若干条指令执行的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行中不许被打断，也就是说CAS是一条CPU的原子指令，不会造成数据不一致问题</p><p>我们点开compareAndSet这个方法会发现底层用到的是compareAndSwapInt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> CAS通过调用JNI的代码实现的。(JNI:Java Native Interface为JAVA本地调用，允许java调用其他语言。)</p><p>而compareAndSwapInt就是借助C来调用CPU底层指令实现的。</p><p>下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p> 可以看到这是个本地方法调用。这个本地方法在openjdk中依次调用的c++代码为：unsafe.cpp，atomic.cpp和atomic<em>windows</em>x86.inline.hpp。这个本地方法的最终实现在openjdk的如下位置：openjdk-7-fcs-src-b147-27<em>jun</em>2011\openjdk\hotspot\src\os<em>cpu\windows</em>x86\vm\ atomic<em>windows</em>x86.inline.hpp（对应于windows操作系统，X86处理器）。下面是对应于intel x86处理器的源代码的片段： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding a lock prefix to an instruction on MP machine</span></span><br><span class="line"><span class="comment">// VC++ doesn't like the lock prefix to be on a single line</span></span><br><span class="line"><span class="comment">// so we can't insert a label after the lock prefix.</span></span><br><span class="line"><span class="comment">// By emitting a lock prefix, we can define a label after it.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp, 0  \</span></span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit <span class="number">0xF0</span> \</span><br><span class="line">                       __asm L0:</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint     exchange_value, <span class="keyword">volatile</span> jint*     dest, jint     compare_value) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如上面源代码所示，程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock  cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。 </p><h4 id="4-CAS的缺点："><a href="#4-CAS的缺点：" class="headerlink" title="4.CAS的缺点："></a>4.CAS的缺点：</h4><p>CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。</p><ol><li>循环时间长开销很大。</li><li>只能保证一个共享变量的原子操作。</li><li>ABA问题。</li></ol><h5 id="4-1循环时间长开销很大："><a href="#4-1循环时间长开销很大：" class="headerlink" title="4.1循环时间长开销很大："></a>4.1循环时间长开销很大：</h5><p>我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。</p><h5 id="4-2只能保证一个共享变量的原子操作："><a href="#4-2只能保证一个共享变量的原子操作：" class="headerlink" title="4.2只能保证一个共享变量的原子操作："></a>4.2只能保证一个共享变量的原子操作：</h5><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p><h5 id="4-3什么是ABA问题？ABA问题怎么解决？"><a href="#4-3什么是ABA问题？ABA问题怎么解决？" class="headerlink" title="4.3什么是ABA问题？ABA问题怎么解决？"></a>4.3什么是ABA问题？ABA问题怎么解决？</h5><p>如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？</p><p>如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-什么是CAS？&quot;&gt;&lt;a href=&quot;#1-什么是CAS？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是CAS？&quot;&gt;&lt;/a&gt;1.什么是CAS？&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="多线程" scheme="http://dumengblog.club/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="http://dumengblog.club/2020/02/01/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://dumengblog.club/2020/02/01/volatile关键字/</id>
    <published>2020-02-01T05:03:21.000Z</published>
    <updated>2020-02-02T05:46:22.893Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么是volatile？"><a href="#1-什么是volatile？" class="headerlink" title="1.什么是volatile？"></a>1.什么是volatile？</h4><p>volatile是一个类型修饰符，它是被设计用来修饰不同线程访问和修改的变量。被volatile定义的变量，每次掉用都是直接从对应的内存中进行提取，而不会利用缓存。</p><a id="more"></a><p>总而言之：</p><p>volatile是java虚拟机提供的轻量级的同步机制。</p><h4 id="2-volatile的三大特性"><a href="#2-volatile的三大特性" class="headerlink" title="2.volatile的三大特性"></a>2.volatile的三大特性</h4><ol><li>保证可见性</li><li>不保证原子性</li><li>禁止指令重排</li></ol><h4 id="3-什么是JMM"><a href="#3-什么是JMM" class="headerlink" title="3.什么是JMM"></a>3.什么是JMM</h4><p>JMM（java内存模型Java Memory Model）本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这个规范定义了程序中各个变量的访问方式。</p><p>Java关于同步的规定：</p><ol><li><p>线程解锁前，必须把共享变量的值刷新回主内存</p></li><li><p>线程加锁前，必须读取主内存的最新值到自己的工作内存</p></li><li><p>加锁解锁，是同一把锁</p><p><strong>主内存（Main Memory）</strong></p></li></ol><p>​    主内存可以简单理解为计算机当中的内存，但又不完全等同。</p><p>​    主内存被所有线程共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的”本尊”。</p><p><strong>工作内存（Working Memory）</strong></p><p>​     工作内存可以理解为计算机当中的CPU高速缓存，但又不完全等同。</p><p>​      每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的”副本”。</p><p><strong>注意</strong>：</p><p>线程对【共享变量】的所有操作都必须在【工作内存】中进行，不能直接读写【主内存】中的变量。</p><p>不同线程之间也无法访问彼此的【工作内存】，【变量值的传递】只能通过【主内存】来进行。</p><p>直接操作【主内存】太慢，所以JVM才不得不利用性能较高的【工作内存】。</p><p>​    【工作内存】所更新的【变量】并不会立即同步到主内存。</p><h4 id="4-什么是可见性"><a href="#4-什么是可见性" class="headerlink" title="4.什么是可见性"></a>4.什么是可见性</h4><p>首先说一下可见性： 当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。 </p><h4 id="5-不保证原子性"><a href="#5-不保证原子性" class="headerlink" title="5.不保证原子性"></a>5.不保证原子性</h4><p>例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">volatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 开启10个线程</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个线程中让count的值自增100次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"count= "</span> + count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序很简单，同时开启十个线程，每个线程都让count加100，最终执行后可能值不是1000。</p><p> 这是因为count++这一行代码本身并不是原子性操作，在字节码层面可以拆分成如下指令：<br>         getstatic     //读取静态变量（count）<br>         iconst_1     //定义常量1<br>         iadd            //count增加1<br>         putstatic     //把count结果同步到主内存 </p><p>虽然每一次执行 getstatic 的时候，获取到的都是主内存的最新变量值，但是进行iadd的时候，由于并不是原子性操作，其他线程在这过程中很可能让count自增了很多次。</p><p>这样一来本线程所计算更新的是一个陈旧的count值，自然无法做到线程安全：</p><h4 id="6-Volatile对【指令的重排序】影响"><a href="#6-Volatile对【指令的重排序】影响" class="headerlink" title="6.Volatile对【指令的重排序】影响"></a>6.Volatile对【指令的重排序】影响</h4><p>​      1）什么是指令重排序？</p><p>​              指令重排序是指： JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。</p><p>​      2）指令重排序的【目的】？</p><p>​              目的：为了在不改变程序执行结果的前提下，优化程序的运行效率。</p><p>​              需要注意的是，这里所说的不改变执行结果，指的是【单线程】下的程序执行结果。</p><p>​      3）然而，指令重排序是一把双刃剑，虽然优化了程序的执行效率，但是在某些情况下，会影响到【多线程】的执行结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-什么是volatile？&quot;&gt;&lt;a href=&quot;#1-什么是volatile？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是volatile？&quot;&gt;&lt;/a&gt;1.什么是volatile？&lt;/h4&gt;&lt;p&gt;volatile是一个类型修饰符，它是被设计用来修饰不同线程访问和修改的变量。被volatile定义的变量，每次掉用都是直接从对应的内存中进行提取，而不会利用缓存。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="高级知识点" scheme="http://dumengblog.club/tags/%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://dumengblog.club/2020/01/19/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://dumengblog.club/2020/01/19/Redis主从复制/</id>
    <published>2020-01-19T03:23:33.000Z</published>
    <updated>2020-01-19T04:25:44.314Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis主从复制前言"><a href="#Redis主从复制前言" class="headerlink" title="Redis主从复制前言"></a><strong>Redis主从复制前言</strong></h4><a id="more"></a><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会丢失（或少量丢失）数据，但是由于数据是存储在一台服务器上的，如果这台服务器出现故障，比如硬盘坏了，也会导致数据丢失。</p><p>为了避免单点故障，我们需要将数据复制多份部署在多台不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。</p><p>这就要求当一台服务器上的数据更新后，自动将更新的数据同步到其他服务器上，这时候就用到了Redis的主从复制。<img src="/../asset/404112134DA9CF20F7C71E6903FF4748.jpg" alt="img" style="zoom:67%;"></p><p><img src="/../asset/36A209B84F1AD2BAA4F3807E4678BDA2.jpg" alt="img"></p><h4 id="主从复制概述"><a href="#主从复制概述" class="headerlink" title="主从复制概述"></a>主从复制概述</h4><p>在Redis客户端通过<strong>info replication</strong>可以查看与复制相关的状态，对于了解主从节点的当前状态，以及解决出现的问题都会有帮助。</p><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><p>主从复制的作用主要包括：</p><ol><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><h4 id="主从复制工作流程"><a href="#主从复制工作流程" class="headerlink" title="主从复制工作流程"></a>主从复制工作流程</h4><p>主从复制过程大体可以分为3个阶段：<strong>连接建立阶段（即准备阶段）</strong>、<strong>数据同步阶段</strong>、<strong>命令传播阶段</strong>；</p><h5 id="1-连接建立阶段"><a href="#1-连接建立阶段" class="headerlink" title="1.连接建立阶段"></a>1.连接建立阶段</h5><p><strong>step1：保存主节点信息</strong></p><p>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</p><p>slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p><p><strong>step2：建立socket连接</strong></p><p><strong>从节点每秒1次调用复制定时函数replicationCron()</strong>，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。</p><p>如果连接成功：</p><p>从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p><p>主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，<strong>并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</strong></p><p><strong>step3：发送ping命令</strong></p><p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</p><p>从节点发送ping命令后，可能出现3种情况：</p><p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p><p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p><p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p><p><strong>step4：身份验证</strong></p><p>如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。</p><p>从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p><p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p><p><strong>step5：发送从节点端口信息</strong></p><p>身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；<strong>该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</strong></p><h5 id="2-数据同步阶段"><a href="#2-数据同步阶段" class="headerlink" title="2.数据同步阶段"></a>2.数据同步阶段</h5><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p><p>具体执行的方式是：从节点向主节点发送psync命令，开始同步。</p><p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制和部分复制</strong>。</p><p>在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p><h5 id="3-命令传播阶段"><a href="#3-命令传播阶段" class="headerlink" title="3.命令传播阶段"></a>3.命令传播阶段</h5><p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。</p><p>PS：</p><p><strong>延迟与不一致：</strong>命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p><p>repl-disable-tcp-nodelay  no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p><h4 id="如何使用主从复制"><a href="#如何使用主从复制" class="headerlink" title="如何使用主从复制"></a>如何使用主从复制</h4><h5 id="开启主从复制"><a href="#开启主从复制" class="headerlink" title="开启主从复制"></a>开启主从复制</h5><p><strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p><p>从节点开启主从复制，有3种方式：</p><ul><li>配置文件：在从服务器的配置文件中加入：slaveof <masterip> <masterport></masterport></masterip></li><li>启动命令：redis-server启动命令后加入 –slaveof <masterip> <masterport></masterport></masterip></li><li>客户端命令：Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip> <masterport>，则该Redis实例成为从节点。</masterport></masterip></li></ul><h5 id="断开主从复制"><a href="#断开主从复制" class="headerlink" title="断开主从复制"></a>断开主从复制</h5><p>通过slaveof <masterip> <masterport>命令建立主从复制关系以后，可以通过slaveof no one断开。</masterport></masterip></p><p>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p><h4 id="【数据同步阶段】全量复制和部分复制"><a href="#【数据同步阶段】全量复制和部分复制" class="headerlink" title="【数据同步阶段】全量复制和部分复制"></a>【数据同步阶段】全量复制和部分复制</h4><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；</p><p>在Redis2.8以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p><ol><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ol><h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><p>Redis通过psync命令进行全量复制的过程如下：</p><p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；</p><p>（2）主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</p><p>（3）主节点的bgsave执行完成后，将RDB文件发送给从节点；<strong>从节点首先清除自己的旧数据，然后载入接收的**</strong>RDB<strong>**文件</strong>，将数据库状态更新至主节点执行bgsave时的数据库状态</p><p>（4）主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p><p>（5）如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态</p><p>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p><p>（1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；</p><p>（2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</p><p>（3）从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</p><h5 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h5><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p><p>部分复制的实现，依赖于三个重要的概念：复制偏移量，复制积压缓冲区，服务器运行ID</p><p><strong>复制偏移量</strong></p><p>主节点和从节点分别维护一个复制偏移量（offset），代表的是<strong>主节点向从节点传递的字节数</strong>；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p><p>offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p><p><strong>复制积压缓冲区</strong></p><p>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p><p>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p><p>由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p><ul><li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li><li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li></ul><p><strong>服务器运行ID(runid)</strong></p><p>每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；</p><p>runid用来唯一识别一个Redis节点。<strong>通过info Server命令，可以查看节点的runid。</strong></p><p>主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><p><strong>psync命令的执行</strong></p><p><img src="/../asset/990532-20180913134017449-1623896661.png" alt="img"></p><p>（1）首先从节点根据当前状态，决定如何调用psync命令：</p><ul><li>如果从节点之前未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制；</li><li>如果从节点之前执行了slaveof，则发送命令为psync <runid> <offset>，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。</offset></runid></li></ul><p>（2）主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：</p><ul><li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；</li><li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li><li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC <runid>  <offset>，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</offset></runid></li></ul><h4 id="【命令传播阶段】心跳机制"><a href="#【命令传播阶段】心跳机制" class="headerlink" title="【命令传播阶段】心跳机制"></a>【命令传播阶段】心跳机制</h4><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。<br>主-&gt;从：PING</p><p>每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。</p><p>PING发送的频率由 repl-ping-slave-period 参数控制，单位是秒，默认值是10s。<br>从-&gt;主：REPLCONF ACK</p><p>在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。</p><p>REPLCONF ACK命令的作用包括：</p><p>（1）实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1。</p><p>（2）检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</p><p>（3）辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Redis主从复制前言&quot;&gt;&lt;a href=&quot;#Redis主从复制前言&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;Redis主从复制前言&lt;/strong&gt;&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis删除策略</title>
    <link href="http://dumengblog.club/2020/01/18/Redis%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5/"/>
    <id>http://dumengblog.club/2020/01/18/Redis删除策略/</id>
    <published>2020-01-18T06:25:13.000Z</published>
    <updated>2020-01-18T06:31:38.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h4><a id="more"></a><p><strong>定时删除</strong>（redis未使用该策略）：在设置键的过期时间时，同时创建一个定时器，让定时器在键过期时间来临时执行对键的删除操作</p><p><strong>惰性删除</strong>：当客户端从键空间中获取键时，通过db./expireIfNeeded函数检查键是否过期，过期则删除，否则返回该键</p><p><strong>定期删除</strong>：Redis服务器周期性操作redis.c/serverCron函数执行，会调用redis.c/activeExpireCycle函数，该函数会在规定时间内，分多次遍历服务器中各个数据库，从该数据库的expires字典中随机检查一部分键的过期时间。（通过全局变量current_db记录activeExpireCycle函数的检查进度，在下次调用该函数时通过该变量继续接着上一次的进度）</p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>优点：对内存是友好的，通过定时器可以保证过期键尽可能快的被删除，并释放其占用空间。<br>缺点：对CPU时间是不友好的，在内存不紧张但是CPU时间非常紧张的情况下，切换cpu执行定时器事件，会影响服务器的响应时间和吞吐量。</p><p>注意：创建定时器需要用到redis服务器中的时间事件，而时间事件是使用无序链表实现的，查找一个事件的时间复杂度为O(n)—不能高效处理大量时间事件</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>优点：对CPU时间是友好的，程序只会在获取键时对键进行检查，删除过期键。<br>缺点：对内存是不友好的，如果一个键过期，只要这个键没有被获取就会一直保存在数据库中，它所占内存就一直不会被释放。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</p><p>如果删除操作执行太频繁，或执行时间太长，定期删除策略就会退化为定时删除策略<br>如果删除操作执行太少，或执行时间太短，定期删除策略就会退化为惰性删除策略</p><p>【转】原文链接：<a href="https://blog.csdn.net/qq_34092585/article/details/82148638" target="_blank" rel="noopener">https://blog.csdn.net/qq_34092585/article/details/82148638</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;过期键的删除策略&quot;&gt;&lt;a href=&quot;#过期键的删除策略&quot; class=&quot;headerlink&quot; title=&quot;过期键的删除策略&quot;&gt;&lt;/a&gt;过期键的删除策略&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 事务</title>
    <link href="http://dumengblog.club/2020/01/18/Redis-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://dumengblog.club/2020/01/18/Redis-事务/</id>
    <published>2020-01-18T02:39:22.000Z</published>
    <updated>2020-01-18T06:14:08.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis事务的概念："><a href="#Redis事务的概念：" class="headerlink" title="Redis事务的概念："></a><strong>Redis事务的概念：</strong></h4><p>　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>　　总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　　</p><a id="more"></a><h4 id="Redis事务没有隔离级别的概念："><a href="#Redis事务没有隔离级别的概念：" class="headerlink" title="Redis事务没有隔离级别的概念："></a><strong>Redis事务没有隔离级别的概念：</strong></h4><p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。                                </p><h4 id="Redis不保证原子性："><a href="#Redis不保证原子性：" class="headerlink" title="Redis不保证原子性："></a><strong>Redis不保证原子性：</strong></h4><p>　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><h4 id="Redis事务的三个阶段："><a href="#Redis事务的三个阶段：" class="headerlink" title="Redis事务的三个阶段："></a><strong>Redis事务的三个阶段：</strong></h4><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p><strong>Redis事务相关命令：</strong></p><p>　　watch key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</p><p>　　multi : 标记一个事务块的开始（ queued ）</p><p>　　exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</p><p>　　discard : 取消事务，放弃事务块中的所有命令</p><p>​        unwatch : 取消watch对所有key的监控</p><p><strong>Redis事务使用案例：</strong></p><ol><li>正常使用</li></ol><img src="/../asset/image-20200118125455977.png" alt="image-20200118125455977" style="zoom:67%;"> <ol start="2"><li>放弃事务</li></ol><img src="/../asset/image-20200118125910224.png" alt="image-20200118125910224" style="zoom: 67%;"> <ol start="3"><li>定义事务的过程中，命令格式输入错误，整体事务中的所有命令均不会执行，包括正确的命令</li></ol><img src="/../asset/image-20200118132620656.png" alt="image-20200118132620656" style="zoom:67%;"> <ol start="4"><li>定义事务的过程中，命令执行错误，例如给list进行incr操作，能够运行正确的命令，运行错误的命令不会被执行并且会抛出异常。</li></ol><img src="/../asset/image-20200118132131276.png" alt="image-20200118132131276" style="zoom:67%;"> <ol start="5"><li>使用watch （开启事务之前）</li></ol><p>（1）监控name，age在事务中更改没有问题</p><p><img src="/../asset/image-20200118133603526.png" alt="image-20200118133603526"> </p><p>（2）再开一个服务端，在事务开启时对name进行更改，事务执行失败</p><p><img src="/../asset/image-20200118133927281.png" alt="image-20200118133927281"></p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><h5 id="基于特定条件的事务执行"><a href="#基于特定条件的事务执行" class="headerlink" title="基于特定条件的事务执行"></a>基于特定条件的事务执行</h5><p><strong>业务场景</strong><br>天猫双11热卖过程中，对已经售完的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空,如何避免最后一件商品不被多人同时购买? [超卖问题]<br>业务分析<br>●使用watch监控一个key有没有改变已经不能解决问题，此处要监控的是具体数据<br>●虽然redis是 单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改? </p><p> <strong>解决方案</strong><br>●使用setnx设置一个公共锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx lock-key value</span><br></pre></td></tr></table></figure><p>利用setnx命令的返回值特征，有值则返回设置失败，无值则返回设置成功<br>●对于返回设置成功的，拥有控制权，进行下一 步的具体业务操作，对于返回设置失败的，不具有控制权，排队或等待</p><p>操作完毕通过del操作释放锁 </p><p><img src="/../asset/image-20200118135938108.png" alt="image-20200118135938108"></p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>由于锁操作由用户控制加锁解锁，那么必然会出现未解锁的风险</p><p>需要解锁不能只由用户来控制，系统级别要给出对应的解锁方案。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire <span class="keyword">lock</span>—<span class="keyword">key</span> <span class="keyword">value</span></span><br><span class="line">pexpire <span class="keyword">lock</span>-<span class="keyword">key</span> milliseconds</span><br></pre></td></tr></table></figure><p><img src="/../asset/image-20200118141351332.png" alt="image-20200118141351332"> </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Redis事务的概念：&quot;&gt;&lt;a href=&quot;#Redis事务的概念：&quot; class=&quot;headerlink&quot; title=&quot;Redis事务的概念：&quot;&gt;&lt;/a&gt;&lt;strong&gt;Redis事务的概念：&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/p&gt;
&lt;p&gt;　　总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　　&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://dumengblog.club/2020/01/17/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E2%80%94/"/>
    <id>http://dumengblog.club/2020/01/17/Redis持久化—/</id>
    <published>2020-01-17T12:35:04.000Z</published>
    <updated>2020-01-18T02:37:59.372Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-什么叫持久化？"><a href="#1-什么叫持久化？" class="headerlink" title="1. 什么叫持久化？"></a>1. 什么叫持久化？</h4><a id="more"></a><p> 用一句话可以将持久化概括为：将数据（如内存中的对象）保存到可永久保存的存储设备中。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、 XML 数据文件中等等。 </p><h4 id="2-持久化的两种方式"><a href="#2-持久化的两种方式" class="headerlink" title="2. 持久化的两种方式"></a>2. 持久化的两种方式</h4><p>Redis为持久化提供了两种方式：</p><ul><li>RDB：在指定的时间间隔能对你的数据进行快照存储。</li><li>AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。</li></ul><h4 id="3-RDB"><a href="#3-RDB" class="headerlink" title="3. RDB"></a>3. RDB</h4><p>RDB：是redis的默认持久化机制。   </p><p>RDB相当于照快照，保存的是一种状态。</p><h5 id="3-1-RDB的持久化配置"><a href="#3-1-RDB的持久化配置" class="headerlink" title="3.1 RDB的持久化配置"></a>3.1 RDB的持久化配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 时间策略</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 文件保存路径</span><br><span class="line">dir /home/work/app/redis/data/</span><br><span class="line"></span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><p>配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。</p><ul><li><code>save 900 1</code> 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份</li><li><code>save 300 10</code> 表示300s内有10条写入，就产生快照</li></ul><p>下面的类似，那么为什么需要配置这么多条规则呢？因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。</p><p><code>stop-writes-on-bgsave-error yes</code> 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。<strong>如果自己的业务有完善的监控系统，可以禁止此项配置，</strong> 否则请开启。</p><p>关于压缩的配置 <code>rdbcompression yes</code> ，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。</p><p>当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：<code>save &quot;&quot;</code></p><h5 id="3-2-RDB的原理"><a href="#3-2-RDB的原理" class="headerlink" title="3.2 RDB的原理"></a>3.2 RDB的原理</h5><p>在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。</p><p><strong>针对RDB方式的持久化，手动触发可以使用：</strong></p><ul><li>save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。</li><li>bgsave：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。</li></ul><p><strong>而自动触发的场景主要是有以下几点：</strong></p><ul><li>根据我们的 <code>save m n</code> 配置规则自动触发；</li><li>从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发 <code>bgsave</code>；</li><li>执行 <code>debug reload</code> 时；</li><li>执行  <code>shutdown</code>时，如果没有开启aof，也会触发。</li></ul><p>由于 <code>save</code> 基本不会被使用到，我们重点看看 <code>bgsave</code> 这个命令是如何完成RDB的持久化的。</p> <img src="/../asset/3084708676-5b70e0fd04072_articlex.png" alt="image1" style="zoom:50%;"> <p> 这里注意的是 <code>fork</code> 操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。 </p><h4 id="4-AOF"><a href="#4-AOF" class="headerlink" title="4. AOF"></a>4. AOF</h4><h5 id="4-1-AOF的配置"><a href="#4-1-AOF的配置" class="headerlink" title="4.1 AOF的配置"></a>4.1 AOF的配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 文件名称</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 同步方式</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 重写触发配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 加载aof时如果有错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 文件重写策略</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><p>还是重点解释一些关键的配置：</p><p><code>appendfsync everysec</code> 它其实有三种模式:</p><ul><li>always：把每个写命令都立即同步到aof，很慢，但是很安全</li><li>everysec：每秒同步一次，是折中方案</li><li>no：redis不处理交给OS来处理，非常快，但是也最不安全</li></ul><p>一般情况下都采用 <strong>everysec</strong> 配置，这样可以兼顾速度与安全，最多损失1s的数据。</p><p><code>aof-load-truncated yes</code> 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 <code>no</code> ，发现错误就会停止，必须修复后才能重新加载。</p><h5 id="4-2-AOF的原理"><a href="#4-2-AOF的原理" class="headerlink" title="4.2 AOF的原理"></a>4.2 AOF的原理</h5><p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 <code>appendfsync everysec</code> 配置，会有1s损耗），第二步是对aof文件的重写。</p><p>对于增量追加到文件这一步主要的流程是：命令写入=》追加到aof_buf =》同步到aof磁盘。那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。</p><p>aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。</p><p><strong>手动触发：</strong> <code>bgrewriteaof</code>，<strong>自动触发</strong> 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</p> <img src="/../asset/2347795269-5b70e0fd162b4_articlex.png" alt="image2" style="zoom:50%;"> <p>对于上图有四个关键点补充一下：</p><ol><li>在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。</li><li>为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。</li><li>重写是直接把当前内存的数据生成对应命令，并不需要读取老的AOF文件进行分析、命令合并。</li><li>AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。</li></ol><h4 id="5-从持久化中恢复数据"><a href="#5-从持久化中恢复数据" class="headerlink" title="5. 从持久化中恢复数据"></a>5. 从持久化中恢复数据</h4><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><p>其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：</p> <img src="/../asset/1500187847-5b70e0fd040ac_articlex.png" alt="image2" style="zoom:50%;"> <p> 启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，AOF基本上最多损失1s的数据。 </p><h4 id="6-RDB和AOF的区别"><a href="#6-RDB和AOF的区别" class="headerlink" title="6. RDB和AOF的区别"></a>6. RDB和AOF的区别</h4><p> <strong>RDB持久化</strong>是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。 </p><p> <strong>AOF持久化</strong>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 </p><p><strong>1. RDB存在哪些优势呢？</strong></p><p>1).  一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数 据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</p><p>2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</p><p>3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p><p>4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p><p><strong>2. RDB又存在哪些劣势呢？</strong></p><p>1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p><p>2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p><p><strong>3. AOF的优势有哪些呢？</strong></p><p>1).  该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其 效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变 化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</p><p>2).  由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操 作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据 一致性的问题。</p><p>3).  如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创 建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p><p>4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p><p><strong>4. AOF的劣势有哪些呢？</strong></p><p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><p>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p><p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p><p><img src="/../asset/image-20200118103742898.png" alt="image-20200118103742898"></p><p>转自<a href="https://segmentfault.com/a/1190000015983518" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015983518</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-什么叫持久化？&quot;&gt;&lt;a href=&quot;#1-什么叫持久化？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么叫持久化？&quot;&gt;&lt;/a&gt;1. 什么叫持久化？&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>jedis常规操作演示</title>
    <link href="http://dumengblog.club/2020/01/17/jedis%E5%B8%B8%E8%A7%84%E6%93%8D%E4%BD%9C%E6%BC%94%E7%A4%BA/"/>
    <id>http://dumengblog.club/2020/01/17/jedis常规操作演示/</id>
    <published>2020-01-17T02:27:40.000Z</published>
    <updated>2020-01-17T03:27:24.002Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-常用操作"><a href="#1-常用操作" class="headerlink" title="1.常用操作"></a>1.常用操作</h4><a id="more"></a><p>本次只列出了String 、hash、List，顺便复习了一下map的几种遍历方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">redisTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.连接redis</span></span><br><span class="line">Jedis jedis=<span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2.操作redis</span></span><br><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"dumeng"</span>);</span><br><span class="line">String name=jedis.get(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//3.关闭redis</span></span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.连接redis</span></span><br><span class="line">Jedis jedis=<span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2.操作redis</span></span><br><span class="line">jedis.lpush(<span class="string">"list1"</span>, <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">jedis.rpush(<span class="string">"list1"</span>, <span class="string">"d"</span>);</span><br><span class="line">List&lt;String&gt; list1 = jedis.lrange(<span class="string">"list1"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String string : list1) &#123;</span><br><span class="line">System.out.print(string+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n"</span>+jedis.llen(<span class="string">"list1"</span>));</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//3.关闭redis</span></span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.连接redis</span></span><br><span class="line">Jedis jedis=<span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2.操作redis</span></span><br><span class="line">jedis.hset(<span class="string">"hash1"</span>, <span class="string">"a1"</span>, <span class="string">"a1"</span>);</span><br><span class="line">jedis.hset(<span class="string">"hash1"</span>, <span class="string">"a2"</span>, <span class="string">"a2"</span>);</span><br><span class="line">Map&lt;String, String&gt; map1 = jedis.hgetAll(<span class="string">"hash1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//常见遍历map的几种方法</span></span><br><span class="line"><span class="comment">//1.foreach 方法</span></span><br><span class="line"><span class="comment">//for(Map.Entry&lt;String, String&gt; entry : map1.entrySet())&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("key: "+entry.getKey()+" value: "+entry.getValue());</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//2.foreach循环中遍历keys或者values</span></span><br><span class="line"><span class="comment">//for(String key:map1.keySet())&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("key: "+key);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//for(String value:map1.values())&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("value: "+value);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//3.使用Iterator</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt;  entry=map1.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(entry.hasNext())&#123;</span><br><span class="line">Map.Entry&lt;String, String&gt; entries=entry.next();</span><br><span class="line">System.out.println(<span class="string">"key: "</span>+entries.getKey()+<span class="string">" value: "</span>+entries.getValue());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.hlen(<span class="string">"hash1"</span>));</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//3.关闭redis</span></span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实际案例"><a href="#2-实际案例" class="headerlink" title="2.实际案例"></a>2.实际案例</h4><p><img src="/../asset/image-20200117103507090.png" alt="image-20200117103507090"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.exceptions.JedisDataException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Service</span><span class="params">(String id,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id=id;</span><br><span class="line"><span class="keyword">this</span>.num=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制单元</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line">String value = jedis.get(<span class="string">"comid"</span> + id);</span><br><span class="line"><span class="comment">// 判断该值是否存在</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 不存在</span></span><br><span class="line">jedis.setex(<span class="string">"comid"</span> + id, <span class="number">5</span>, Long.MAX_VALUE - num + <span class="string">""</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">Long incr = jedis.incr(<span class="string">"comid"</span> + id);</span><br><span class="line">business(id,num-(Long.MAX_VALUE-incr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (JedisDataException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"使用次数到达上限，请升级会员"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">(String id, Long incr)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"用户"</span>+id+<span class="string">"业务操作执行"</span>+incr+<span class="string">"次"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"初级用户"</span>,<span class="number">10</span>);</span><br><span class="line">MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"高级用户"</span>,<span class="number">30</span>);</span><br><span class="line">mt1.start();</span><br><span class="line">mt2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">Service sc;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String id,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">sc = <span class="keyword">new</span> Service(id,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">sc.service();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">300L</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="/../asset/image-20200117111521663.png" alt="image-20200117111521663"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-常用操作&quot;&gt;&lt;a href=&quot;#1-常用操作&quot; class=&quot;headerlink&quot; title=&quot;1.常用操作&quot;&gt;&lt;/a&gt;1.常用操作&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Jedis简单测试</title>
    <link href="http://dumengblog.club/2020/01/16/Jedis/"/>
    <id>http://dumengblog.club/2020/01/16/Jedis/</id>
    <published>2020-01-16T02:53:27.000Z</published>
    <updated>2020-01-16T04:12:31.724Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Jedis概述"><a href="#1-Jedis概述" class="headerlink" title="1. Jedis概述"></a>1. Jedis概述</h4><p> Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码 </p><a id="more"></a><h4 id="2-jar包下载和导入"><a href="#2-jar包下载和导入" class="headerlink" title="2. jar包下载和导入"></a>2. jar包下载和导入</h4><p><strong>（首先个人建议下低版本的，因为jedis版本越高对你的jdk版本要求也会越高）</strong></p><p><a href="https://mvnrepository.com/artifact/redis.clients/jedis/3.2.0" target="_blank" rel="noopener">https://mvnrepository.com/artifact/redis.clients/jedis/3.2.0</a></p><img src="/../asset/image-20200116105657435.png" alt="image-20200116105657435" style="zoom:50%;"> <p>我用的my eclipse，新建一个Java工程，右键项目，Build Path-&gt;Configure Build Path,在library下点击Add External JARs，将你下载的jar包导入即可</p><p><img src="/../asset/image-20200116112015992.png" alt="image-20200116112015992"></p><h4 id="3-简单测试"><a href="#3-简单测试" class="headerlink" title="3.简单测试"></a>3.简单测试</h4><p>利用单元测试来测试我们书写的代码，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">redisTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RedisTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.连接redis</span></span><br><span class="line">Jedis jedis=<span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2.操作redis</span></span><br><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"dumeng"</span>);</span><br><span class="line">String name=jedis.get(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//3.关闭redis</span></span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终测试台显示：</p><p><img src="/../asset/image-20200116114806971.png" alt="image-20200116114806971"> </p><p>测试成功。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-Jedis概述&quot;&gt;&lt;a href=&quot;#1-Jedis概述&quot; class=&quot;headerlink&quot; title=&quot;1. Jedis概述&quot;&gt;&lt;/a&gt;1. Jedis概述&lt;/h4&gt;&lt;p&gt; Jedis是Redis官方推荐的Java连接开发工具。要在Java开发中使用好Redis中间件，必须对Jedis熟悉才能写成漂亮的代码 &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis key通用操作</title>
    <link href="http://dumengblog.club/2020/01/15/Redis-key%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://dumengblog.club/2020/01/15/Redis-key通用操作/</id>
    <published>2020-01-15T02:41:38.000Z</published>
    <updated>2020-01-15T03:20:31.380Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-key基本操作"><a href="#1-key基本操作" class="headerlink" title="1. key基本操作"></a>1. key基本操作</h4><a id="more"></a><p>删除指定key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>获取key是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><p>获取key的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><img src="/../asset/image-20200115104934791.png" alt="image-20200115104934791" style="zoom:50%;"><h4 id="2-key的扩展操作"><a href="#2-key的扩展操作" class="headerlink" title="2. key的扩展操作"></a>2. key的扩展操作</h4><h5 id="2-1-时效性控制"><a href="#2-1-时效性控制" class="headerlink" title="2.1 时效性控制"></a>2.1 时效性控制</h5><p>为key设置有效期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br></pre></td></tr></table></figure><p>获取key的有效时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br><span class="line">pttl key</span><br></pre></td></tr></table></figure><p>切换key从有效性转换为永久性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key</span><br></pre></td></tr></table></figure><img src="/../asset/image-20200115110528474.png" alt="image-20200115110528474" style="zoom:67%;"> <h5 id="2-2-查询模式"><a href="#2-2-查询模式" class="headerlink" title="2.2 查询模式"></a>2.2 查询模式</h5><p>查询key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key pattern</span><br></pre></td></tr></table></figure><p>查询模式规则</p><p>*：匹配任意数量的任意符号</p><p>？：匹配一个任意符号</p><p>[]：匹配一个指定符号</p><h5 id="3-3-其他操作"><a href="#3-3-其他操作" class="headerlink" title="3.3 其他操作"></a>3.3 其他操作</h5><p>为key改名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br><span class="line">renamenx key newkey//如果不存在改名字</span><br></pre></td></tr></table></figure><p>对所有key排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-key基本操作&quot;&gt;&lt;a href=&quot;#1-key基本操作&quot; class=&quot;headerlink&quot; title=&quot;1. key基本操作&quot;&gt;&lt;/a&gt;1. key基本操作&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据类型——zset</title>
    <link href="http://dumengblog.club/2020/01/14/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94zset/"/>
    <id>http://dumengblog.club/2020/01/14/Redis-数据类型——zset/</id>
    <published>2020-01-14T11:20:19.000Z</published>
    <updated>2020-01-14T11:22:52.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><a id="more"></a><p>1、 Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>2、不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>3、有序集合的成员是唯一的,但分数(score)却可以重复。</p><p>4、集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p>Redis的ZSet是有序、且不重复 </p><p>（很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的）</p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><p>赋值语法： </p><p>ZADD key score1 member1 [score2 member2] </p><p>向有序集合添加一个或多个成员，或者更新已存在成员的分数 </p><p>取值语法： </p><p> ZCARD key  获取有序集合的成员数</p><p> ZCOUNT key min max 计算在有序集合中指定区间分数的成员数</p><p>ZRANK key member 返回有序集合中指定成员的索引</p><p> ZRANGE key start stop [WITHSCORES] </p><p>通过索引区间返回有序集合成指定区间内的成员(低到高)</p><p>ZREVRANGE key start stop [WITHSCORES] </p><p>返回有序集中指定区间内的成员，通过索引，分数从高到底</p><p>删除语法： </p><p> del key  移除集合 </p><p>ZREM key member [member …] 移除有序集合中的一个或多个成员</p><p>ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员(第一名是0)(低到高排序)</p><p>ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据类型——set</title>
    <link href="http://dumengblog.club/2020/01/14/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94set/"/>
    <id>http://dumengblog.club/2020/01/14/Redis-数据类型——set/</id>
    <published>2020-01-14T11:01:39.000Z</published>
    <updated>2020-01-14T11:12:39.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><a id="more"></a><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><p>类似于JAVA中的 Hashtable集合</p><p>redis的集合对象set的底层存储结构特别神奇，底层使用了intset和hashtable两种数据结构存储的，intset我们可以理解为数组，hashtable就是普通的哈希表（key为set的值，value为null）。</p><p>intset内部其实是一个数组（int8_t coentents[]数组），而且存储数据的时候是有序的，因为在查找数据的时候是通过二分查找来实现的。</p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><p><strong>赋值语法：</strong> </p><p> <a href="http://www.runoob.com/redis/sets-sadd.html" target="_blank" rel="noopener">SADD </a><a href="http://www.runoob.com/redis/sets-sadd.html" target="_blank" rel="noopener">key member1 [member2]</a> 向集合添加一个或多个成员 </p><p><strong>取值语法：</strong> </p><p> <a href="http://www.runoob.com/redis/sets-scard.html" target="_blank" rel="noopener">SCARD key</a> 获取集合的成员数 </p><p> <a href="http://www.runoob.com/redis/sets-smembers.html" target="_blank" rel="noopener">SMEMBERS </a><a href="http://www.runoob.com/redis/sets-smembers.html" target="_blank" rel="noopener">key</a> 返回集合中的所有成员 </p><p> <a href="http://www.runoob.com/redis/sets-sismember.html" target="_blank" rel="noopener">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员(开发中：验证是否存在判断） </p><p> <a href="http://www.runoob.com/redis/sets-srandmember.html" target="_blank" rel="noopener">SRANDMEMBER key [count]</a> 返回集合中一个或多个随机数       </p><p><strong>删除语法：</strong> </p><p>SREM key member1 [member2] 移除集合中一个或多个成员</p><p>SPOP key [count] 移除并返回集合中的一个随机元素</p><p>SMOVE source destination member </p><p>将 member 元素从 source 集合移动到 destination 集合</p><p><strong>差集语法：</strong> </p><p>  <a href="http://www.runoob.com/redis/sets-sdiff.html" target="_blank" rel="noopener">SDIFF </a><a href="http://www.runoob.com/redis/sets-sdiff.html" target="_blank" rel="noopener">key1  </a><a href="http://www.runoob.com/redis/sets-sdiff.html" target="_blank" rel="noopener">[key2]</a>  返回给定所有集合的差集(左侧） </p><p>SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中</p><p><strong>交集语法：</strong> </p><p>  <a href="http://www.runoob.com/redis/sets-sinter.html" target="_blank" rel="noopener">SINTER key1 [key2]</a> 返回给定所有集合的交集(共有数据） </p><p>SINTERSTORE destination key1 [key2]  返回给定所有集合的交集并存储在 destination 中</p><p><strong>并集语法：</strong> </p><p>  <a href="http://www.runoob.com/redis/sets-sunion.html" target="_blank" rel="noopener">SUNION key1 [key2]</a> 返回所有给定集合的并集 </p><p>SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据类型——list</title>
    <link href="http://dumengblog.club/2020/01/14/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94list/"/>
    <id>http://dumengblog.club/2020/01/14/Redis-数据类型——list/</id>
    <published>2020-01-14T10:45:07.000Z</published>
    <updated>2020-01-14T10:56:37.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><a id="more"></a><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素) </p><p>类似JAVA中的LinkedList</p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><p><strong>赋值语法：</strong> </p><p>LPUSH key value1 [value2] //将一个或多个值插入到列表头部(从左侧添加)</p><p>RPUSH key value1 [value2] //在列表中添加一个或多个值(从右侧添加)</p><p>LPUSHX key value  //将一个值插入到已存在的列表头部。如果列表不在，操作无效</p><p>RPUSHX key value  //一个值插入已存在的列表尾部(最右边)。如果列表不在，操作无效。</p><p><strong>取值语法：</strong> </p><p>LLEN key   //获取列表长度</p><p>LINDEX key index  //通过索引获取列表中的元素</p><p>LRANGE key start stop //获取列表指定范围内的元素</p><p>描述： 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p><p>start:  页大小*(页数-1)  </p><p>stop : (页大小*页数)-1</p><p><strong>删除语法：</strong></p><p>LPOP key 移出并获取列表的第一个元素(从左侧删除)</p><p>RPOP key  移除列表的最后一个元素，返回值为移除的元素(从右侧删除)</p><p>BLPOP key1 [key2 ] timeout </p><p>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p>实例</p><p>redis 127.0.0.1:6379&gt; BLPOP list1 100</p><p>在以上实例中，操作会被阻塞，如果指定的列表 key list1 存在数据则会返回第一个元素，否则在等待100秒后会返回 nil 。</p><p>BRPOP key1 [key2 ] timeout </p><p>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><p>LTRIM key start stop  对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><p><strong>修改语法：</strong></p><p>LSET key index value 通过索引设置列表元素的值</p><p>LINSERT key BEFORE|AFTER world value 在列表的元素前或者后插入元素</p><p>描述：将值 value 插入到列表 key 当中，位于值 world 之前或之后。</p><p><strong>高级语法：</strong></p><p>RPOPLPUSH source destination </p><p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回<br>示例描述：</p><p>RPOPLPUSH a1  a2  //a1的最后元素移到a2的左侧</p><p>RPOPLPUSH a1  a1 //循环列表，将最后元素移到最左侧</p><p>BRPOPLPUSH source destination timeout </p><p>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据类型——hash</title>
    <link href="http://dumengblog.club/2020/01/14/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94hash/"/>
    <id>http://dumengblog.club/2020/01/14/Redis-数据类型——hash/</id>
    <published>2020-01-14T10:12:31.000Z</published>
    <updated>2020-01-14T10:44:34.792Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><a id="more"></a><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）</p><p> 可以看成具有KEY和VALUE的MAP容器，该类型非常适合于存储值对象的信息， </p><p>如：uname,upass,age等。该类型的数据仅占用很少的磁盘空间（相比于JSON） </p><h4 id="2-Hash命令"><a href="#2-Hash命令" class="headerlink" title="2. Hash命令"></a>2. Hash命令</h4><p><strong>赋值语法：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET KEY  FIELD  VALUE</span><br></pre></td></tr></table></figure><p>为指定的KEY，设定FILD/VALUE  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET  KEY  FIELD VALUE [FIELD1,VALUE1]</span><br></pre></td></tr></table></figure><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p><p><strong>取值语法：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET KEY FIELD</span><br></pre></td></tr></table></figure><p> 获取存储在HASH中的值，根据FIELD得到VALUE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field[field1]</span><br></pre></td></tr></table></figure><p>  获取key所有给定字段的值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p> 返回HASH表中所有的字段和值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure><p> 获取所有哈希表中的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br></pre></td></tr></table></figure><p>获取哈希表中字段的数量</p><p>删除语法： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL KEY field1[field2]</span><br></pre></td></tr></table></figure><p> 删除一个或多个HASH表字段 </p><p><strong>其它语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></table></figure><p>只有在字段 field 不存在时，设置哈希表字段的值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure><p>为哈希表 key 中的指定字段的整数值加上增量 increment 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBYFLOAT key field increment</span><br></pre></td></tr></table></figure><p>为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p> 查看哈希表 key 中，指定的字段是否存在</p><h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h4><p>Hash的应用场景：（存储一个用户信息对象数据）</p><p>1、 常用于存储一个对象</p><p>2、 为什么不用string存储一个对象？</p><p>hash是最接近关系数据库结构的数据类型，可以将数据库一条记录或程序中一个对象转换成hashmap存放在redis中。</p><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：</p><p>  第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。</p><p>  第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。</p><p>总结：</p><p>Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口</p><h4 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4.应用场景"></a>4.应用场景</h4><img src="/../asset/image-20200114183114858.png" alt="image-20200114183114858" style="zoom:67%;"><img src="/../asset/image-20200114183125899.png" alt="image-20200114183125899" style="zoom: 50%;"><img src="/../asset/image-20200114183517341.png" alt="image-20200114183517341" style="zoom:67%;"><img src="/../asset/image-20200114184413147.png" alt="image-20200114184413147" style="zoom:67%;">]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据类型——String</title>
    <link href="http://dumengblog.club/2020/01/14/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E2%80%94%E2%80%94String/"/>
    <id>http://dumengblog.club/2020/01/14/Redis-数据类型——String/</id>
    <published>2020-01-14T04:21:02.000Z</published>
    <updated>2020-01-14T04:52:26.649Z</updated>
    
    <content type="html"><![CDATA[<p><strong>key的命名建议</strong></p><p>redis单个key 存入512M大小</p><p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:123:password;</p><p>4.key名称区分大小写</p><a id="more"></a><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p>string是redis最基本的类型，一个key对应一个value。</p><p>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。</p><p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。  </p><p> 二进制安全是指，在传输数据时，保证二进制数据的信息安全，也就是不被篡改、破译等，如果被攻击，能够及时检测出来 </p><p><strong>二进制安全特点：</strong></p><p>  1、编码、解码发生在客户端完成，执行效率高 </p><p>  2、不需要频繁的编解码，不会出现乱码</p><h4 id="2-String命令"><a href="#2-String命令" class="headerlink" title="2. String命令"></a>2. String命令</h4><p><strong>赋值语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET KEY VALUE</span><br></pre></td></tr></table></figure><p>Redis SET 命令用于设置给定 key 的值。如果 key 已经存储值， SET 就覆写旧值，且无视类型 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value //解决分布式锁 方案之一</span><br></pre></td></tr></table></figure><p>只有在 key 不存在时设置 key 的值。Setnx（SET if Not exists） 命令在指定的 key 不存在时，为 key 设置指定的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET key1 value1 key2 value2 ...</span><br></pre></td></tr></table></figure><p>同时设置一个或多个 key-value 对 </p><p><strong>取值语法：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET KEY_NAME</span><br></pre></td></tr></table></figure><p>Redis GET命令用于获取指定 key 的值。如果 key 不存在，返回 nil 。如果key 储存的值不是字符串类型，返回一个错误。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETRANGE key start end</span><br></pre></td></tr></table></figure><p>用于获取存储在指定 key 中字符串的子字符串。字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key offset</span><br></pre></td></tr></table></figure><p>对 key 所储存的字符串值，获取指定偏移量上的位(bit)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key1 [key2..]</span><br></pre></td></tr></table></figure><p><strong>获取所有(一个或多个)给定 key 的值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSET  KEY_NAME  VALUE</span><br></pre></td></tr></table></figure><p> Getset 命令用于设置指定 key 的值，并返回 key 的旧值,当 key 不存在时，返回 nil </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p>返回 key 所储存的字符串值的长度</p><p><strong>删除语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL KEY_Name</span><br></pre></td></tr></table></figure><p>删除指定的KEY，如果存在，返回值数字类型。 </p><p><strong>自增/自减：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR KEY_Name</span><br></pre></td></tr></table></figure><p>Incr 命令将 key 中储存的数字值增1。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作 </p><p><strong>自增：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY KEY_Name 增量值</span><br></pre></td></tr></table></figure><p> Incrby 命令将 key 中储存的数字加上指定的增量值 </p><p><strong>自减：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR KEY_NAME 或 DECYBY KEY_NAME 减值</span><br></pre></td></tr></table></figure><p> decR 命令将 key 中储存的数字减1</p><p><strong>字符串拼接</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND  KEY_NAME VALUE</span><br></pre></td></tr></table></figure><p> Append 命令用于为指定的 key 追加至未尾，如果不存在，为其赋值 </p><h4 id="3-扩展操作"><a href="#3-扩展操作" class="headerlink" title="3.扩展操作"></a>3.扩展操作</h4><p>设置数据有指定的生命周期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;key的命名建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;redis单个key 存入512M大小&lt;/p&gt;
&lt;p&gt;1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；&lt;br&gt;2.key也不要太短，太短的话，key的可读性会降低；&lt;br&gt;3.在一个项目中，key最好使用统一的命名模式，例如user:123:password;&lt;/p&gt;
&lt;p&gt;4.key名称区分大小写&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础操作</title>
    <link href="http://dumengblog.club/2020/01/14/%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://dumengblog.club/2020/01/14/基础操作/</id>
    <published>2020-01-14T03:26:28.000Z</published>
    <updated>2020-01-14T04:17:16.564Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Redis-命令"><a href="#1-Redis-命令" class="headerlink" title="1.Redis 命令"></a>1.Redis 命令</h4><a id="more"></a><p>Redis 命令用于在 redis 服务上执行操作。</p><p>要在 redis 服务上执行命令需要一个 redis 客户端。</p><p>Redis 客户端在我们之前下载的的 redis 的安装包中。</p><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)等</p><h4 id="2-添加信息"><a href="#2-添加信息" class="headerlink" title="2.添加信息"></a>2.添加信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">key</span> <span class="keyword">value</span></span><br></pre></td></tr></table></figure><h4 id="3-查询信息"><a href="#3-查询信息" class="headerlink" title="3.查询信息"></a>3.查询信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get key</span><br></pre></td></tr></table></figure><p><img src="/../asset/image-20200114121007506.png" alt="image-20200114121007506"></p><h4 id="4-帮助命令"><a href="#4-帮助命令" class="headerlink" title="4.帮助命令"></a>4.帮助命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help 命令名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help @组名</span><br></pre></td></tr></table></figure><img src="/../asset/image-20200114121310756.png" alt="image-20200114121310756" style="zoom:67%;"><h4 id="5-清屏"><a href="#5-清屏" class="headerlink" title="5.清屏"></a>5.清屏</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h4 id="6-退出客户端"><a href="#6-退出客户端" class="headerlink" title="6.退出客户端"></a>6.退出客户端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">exc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-Redis-命令&quot;&gt;&lt;a href=&quot;#1-Redis-命令&quot; class=&quot;headerlink&quot; title=&quot;1.Redis 命令&quot;&gt;&lt;/a&gt;1.Redis 命令&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis简介</title>
    <link href="http://dumengblog.club/2020/01/14/Redis%E7%AE%80%E4%BB%8B/"/>
    <id>http://dumengblog.club/2020/01/14/Redis简介/</id>
    <published>2020-01-14T02:40:49.000Z</published>
    <updated>2020-01-14T02:56:42.597Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1.Redis简介"></a>1.Redis简介</h4><a id="more"></a><img src="/../asset/image-20200114104322678.png" alt="image-20200114104322678" style="zoom: 25%;"><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能(NOSQL)的key-value数据库,Redis是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C</a><a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/数据库" target="_blank" rel="noopener">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。(Vmware在资助着redis项目的开发和维护)</p><hr><p><a href="https://baike.baidu.com/item/BSD" target="_blank" rel="noopener">BSD</a>是”Berkeley Software Distribution”的缩写，<a href="https://baike.baidu.com/item/意思" target="_blank" rel="noopener">意思</a>是”伯克利软件发行版”。</p><p>BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。</p><h4 id="2-Redis作者"><a href="#2-Redis作者" class="headerlink" title="2.Redis作者"></a>2.Redis作者</h4><p>redis的作者，他叫Salvatore Sanfilippo，来自意大利的西西里岛，现在居住在卡塔尼亚。目前供职于Pivotal公司。</p><h4 id="3-NoSQL介绍"><a href="#3-NoSQL介绍" class="headerlink" title="3.NoSQL介绍"></a>3.NoSQL介绍</h4><p>NoSQL，泛指非关系型的数据库。随着互联网<a href="https://baike.baidu.com/item/web2.0" target="_blank" rel="noopener">web2.0</a>网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的<a href="https://baike.baidu.com/item/SNS/10242" target="_blank" rel="noopener">SNS</a>类型的web2.0纯<a href="https://baike.baidu.com/item/动态网" target="_blank" rel="noopener">动态网</a>站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。<strong>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题</strong>。 </p><h5 id="3-1NoSQL数据库的四大分类"><a href="#3-1NoSQL数据库的四大分类" class="headerlink" title="3.1NoSQL数据库的四大分类"></a>3.1NoSQL数据库的四大分类</h5><p><strong>键值存储数据库</strong><br>     这一类数据库主要会使用到一个<a href="https://baike.baidu.com/item/哈希表" target="_blank" rel="noopener">哈希表</a>，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署。但是如果<a href="https://baike.baidu.com/item/DBA/3349" target="_blank" rel="noopener">DBA</a>只对部分值进行查询或更新的时候，Key/value就显得效率低下了。[3] 举例如：Tokyo Cabinet/Tyrant, <strong><em>\</em>Redis**</strong>, Voldemort, Oracle BDB.</p><p><strong>列存储数据库</strong><br>    这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra, <strong><em>\</em>HBase**</strong>, Riak.</p><p><strong>文档型数据库</strong><br>    文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB<strong><em>\</em>,**</strong> <strong><em>\</em>MongoDb**</strong>. 国内也有文档型数据库SequoiaDB，已经开源。</p><p><strong>图形数据库</strong><br>    图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。[2] 如：Neo4J, InfoGrid, Infinite Graph.</p><p>   因此，我们总结NoSQL数据库在以下的这几种情况下比较适用：</p><p>1、数据模型比较简单；</p><p>2、需要灵活性更强的IT系统；</p><p>3、对数据库性能要求较高；</p><p>4、不需要高度的数据一致性；</p><p>5、对于给定key，比较容易映射复杂值的环境。 </p><p><strong><em>\</em>Redis 与其他 key - value 缓存产品有以下三个特点：**</strong></p><p>· Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p><p>· Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>· Redis支持数据的备份，集群等高可用功能。</p><h4 id="4-特点"><a href="#4-特点" class="headerlink" title="4.特点"></a>4.特点</h4><p>· 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</p><p>· 丰富的数据类型 – Redis支持的类型 String, List, Hash, Set 及 Ordered Set 数据类型操作。</p><p>· 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</p><p>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</p><h4 id="5-Redis总结"><a href="#5-Redis总结" class="headerlink" title="5.Redis总结"></a>5.Redis总结</h4><p>redis单个key 存入512M大小</p><p>redis支持多种类型的数据结构(string,list,hash.set.zset)</p><p>redis 是单线程  原子性   </p><p>redis可以持久化  因为使用了 RDB和AOF机制  </p><p>redis支持集群  而且redis 支持库(0-15) 16个库 </p><p>redis 还可以做消息队列  比如聊天室  IM </p><p>企业级开发中:可以用作数据库、缓存(热点数据（经常会被查询，但是不经常被修改或者删除的数据)和消息中间件等大部分功能。</p><p><strong><em>\</em>优点：**</strong> </p><ol><li>丰富的数据结构</li><li>高速读写，redis使用自己实现的分离器，代码量很短，没有使用lock（MySQL），因此效率非常高。 </li></ol><p><strong><em>\</em>缺点：**</strong> </p><ol><li>持久化。Redis直接将数据存储到内存中，要将数据保存到磁盘上，Redis可以使用两种方式实现持久化过程。定时快照（snapshot）：每隔一段时间将整个数据库写到磁盘上，每次均是写全部数据，代价非常高。第二种方式基于语句追加（aof）：只追踪变化的数据，但是追加的log可能过大，同时所有的操作均重新执行一遍，回复速度慢。 </li><li>耗内存，占用内存过高。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-Redis简介&quot;&gt;&lt;a href=&quot;#1-Redis简介&quot; class=&quot;headerlink&quot; title=&quot;1.Redis简介&quot;&gt;&lt;/a&gt;1.Redis简介&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis安装</title>
    <link href="http://dumengblog.club/2020/01/12/Redis%E5%AE%89%E8%A3%85/"/>
    <id>http://dumengblog.club/2020/01/12/Redis安装/</id>
    <published>2020-01-12T12:54:48.000Z</published>
    <updated>2020-01-12T13:26:22.205Z</updated>
    
    <content type="html"><![CDATA[<p>假期终于到了，这个假期准备学习redis以及温习数据库，计算机网络和操作系统的基本知识。<a id="more"></a></p><p>今天，先进行redis的安装。</p><p> <a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">redis官网</a> （访问较慢）</p><img src="/../asset/image-20200112210050940.png" alt="image-20200112210050940" style="zoom:67%;"><p>接着我在E盘中新建了一个文件夹（redis）,将压缩包解压到当前文件夹中，接着</p><p>打开cmd命令窗口，使用命令进行安装和注册redis到window服务</p><p>安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-install redis.windows.conf --loglevel verbose</span><br></pre></td></tr></table></figure><p>启动服务命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-start</span><br></pre></td></tr></table></figure><p>关闭服务命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-stop</span><br></pre></td></tr></table></figure><img src="/../asset/image-20200112211503575.png" alt="image-20200112211503575" style="zoom:67%;"><p>如果出现successfully那么就表示你安装成功了</p><p>我们再重新打开一个cmd ，作为一个客户端调用redis服务，调用命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><p>显示地址和端口，说明调用成功 。</p><p> 然后我们使用set 和get 命令进行测试一下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set uname &quot;abc&quot;</span><br></pre></td></tr></table></figure><p>然后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get uname</span><br></pre></td></tr></table></figure><p>可以获取到对应set的值，说明调用成功 </p><p>然后可以设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET requirepass &quot;root&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假期终于到了，这个假期准备学习redis以及温习数据库，计算机网络和操作系统的基本知识。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Redis" scheme="http://dumengblog.club/tags/Redis/"/>
    
  </entry>
  
</feed>
