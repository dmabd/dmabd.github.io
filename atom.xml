<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dumeng&#39;s Blog</title>
  
  <subtitle>writedown everything</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://dumengblog.club/"/>
  <updated>2019-12-17T12:23:32.478Z</updated>
  <id>http://dumengblog.club/</id>
  
  <author>
    <name>dumeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java多线程—-三种线程的开辟方式</title>
    <link href="http://dumengblog.club/2019/12/17/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%80%E8%BE%9F%E6%96%B9%E5%BC%8F/"/>
    <id>http://dumengblog.club/2019/12/17/java多线程—-常见的两种线程的开辟方式/</id>
    <published>2019-12-17T12:09:02.000Z</published>
    <updated>2019-12-17T12:23:32.478Z</updated>
    
    <content type="html"><![CDATA[<p>对于所有语言来说，多线程的编程是绝不可少的。同样的Java语言也包含了多线程的开发。首先，我们先来了解一下Java语言的多线程实现方式。</p><a id="more"></a><p>一、Java 多线程实现方式</p><p>java中实现多线程的方式有三种，接下来我将会逐个进行介绍。</p><p><strong>1.继承Thread类</strong></p><p>继承Thread类是Java中比较常见，也是很基础的一种实现Java多线程的方式。实现的方式也比较简单，只要将需要实现多线程的Java类继承java.lang.Thread类，重写run（）方法即可。</p><p><strong>2.实现Runnable接口</strong></p><p>1.实现Runnable接口，并且实现run（）方法。</p><p>2.创建Thread对象，用实现Runnable接口的对象作为参数实例化该对象</p><p>3.调用Thread的start（）方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程实例化</span></span><br><span class="line"><span class="comment">//1.继承Thread类，做一个线程子类</span></span><br><span class="line">Mythread mt=<span class="keyword">new</span> Mythread();</span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line"><span class="comment">//需要调用start（）方法，使线程启动</span></span><br><span class="line"><span class="comment">//start方法会开启一个新的线程，来执行run中的逻辑</span></span><br><span class="line"><span class="comment">//如果直接调用run（）方法，则线程不会进入到就绪状态</span></span><br><span class="line">mt.start();</span><br><span class="line">System.out.println(<span class="string">"主线程逻辑结束了"</span>);</span><br><span class="line"><span class="comment">//2.实现runnable接口</span></span><br><span class="line">Mythread2 mt2=<span class="keyword">new</span> Mythread2();</span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(mt2);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *这是一个自定义的线程类 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需要重写run方法</span></span><br><span class="line"><span class="comment"> * 将需要并发执行的方法写到run方法当中</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"子线程中的逻辑："</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 需要重写run方法</span></span><br><span class="line"><span class="comment"> * 将需要并发执行的方法写到run方法当中</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"子线程2中的逻辑："</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.实现Callable接口，重写call（）方法</p><p>Callable是属于Executor框架中的功能类，与Runnable接口相似，但是有比Runnable更强大的功能：</p><p> 1) Callable 可以在任务结束后提供- 个返回值，Runnable 无法提供这个功能。</p><p> 2) Callable 中的call( )方法可以抛出异常，而Runnable的run( )方法不能抛出异常。</p><p> 3)运行Callable可以拿到一个Future 对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监视目标线程调用call()方法的情况，当调用Future 的get( )方法以获取结果时，当前线程就会阻塞，直到ell )方法结束返回结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于所有语言来说，多线程的编程是绝不可少的。同样的Java语言也包含了多线程的开发。首先，我们先来了解一下Java语言的多线程实现方式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java多线程" scheme="http://dumengblog.club/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程—-线程的生命周期</title>
    <link href="http://dumengblog.club/2019/12/17/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://dumengblog.club/2019/12/17/java多线程—-线程的生命周期/</id>
    <published>2019-12-17T04:26:08.000Z</published>
    <updated>2019-12-17T11:37:33.484Z</updated>
    
    <content type="html"><![CDATA[<p>一、线程的生命周期总结下来分为以下五种：</p><a id="more"></a><p>（1）新建：当一个Thread类或其子类的对象被声明并创建时。新生的线程对象属于新建状态。</p><p>（2）就绪：处于新建状态的线程执行start()方法后，进入线程队列等待CPU时间片，该状态具备了运行的状态，只是没有分配到CPU资源。</p><p>（3）运行：当就绪的线程分配到CPU资源便进入运行状态，run()方法定义了线程的操作。</p><p>（4）阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时终止自己的的执行，进入阻塞状态。</p><p>（5）死亡：当线程执行完自己的操作或提前被强制性的终止或出现异常导致结束，会进入死亡状态。</p> <img src="/../asset/1622073-20190704084639126-898750435.png" alt="img" style="zoom:67%;"> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、线程的生命周期总结下来分为以下五种：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java多线程" scheme="http://dumengblog.club/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程—-进程和线程</title>
    <link href="http://dumengblog.club/2019/12/17/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://dumengblog.club/2019/12/17/java多线程—-进程和线程/</id>
    <published>2019-12-17T04:05:22.000Z</published>
    <updated>2019-12-17T04:16:49.940Z</updated>
    
    <content type="html"><![CDATA[<p>下面是抽象类比：</p><a id="more"></a><p>单CPU：一台单核处理器计算机 = 一个车间；<br>多CPU：一台多核处理器计算机 = 一座工厂；</p><p>进程：一个车间 = 一个进程； （即一个运行的程序）</p><p>多进程：一座工厂可以同时运行多个车间；<br>CPU和进程：单CPU只能同时运行单个进程，多CPU可以同时运行多个进程。</p><p>线程：车间内一个工人 = 一个线程；<br>进程与线程：一个进程可以包括多个线程。</p><p>线程间内存共享：车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。<br>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</p><p>内存安全：可是，每个车间容纳大小不同，有的最多只能容纳一个人。车间人满的时候，其他人就进不去了。<br>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</p><p>互斥锁：一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。<br>这就叫”互斥锁”–Mutex，防止两个线程同时读写某一块内存区域。</p><p>信号量：这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。<br>这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。</p><p>锁和信号量：不难看出，互斥锁是信号量的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><p>操作系统的资源分配与调度逻辑</p><p>以多进程形式，允许多个任务同时运行；<br>以多线程形式，允许单个任务分成不同的部分运行；<br>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。<br>下面是严谨的解释：<br>进程<br>进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p><p>线程<br>线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>进程和线程的关系<br>线程是进程的一部分<br>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</p><p>进程和线程的区别<br>理解它们的差别，我从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）</p><p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><p>开销方面：每个进程都有独立的代码和数据空间（程序上下文），进程之间切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</p><p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p>内存分配：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</p><p>包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是抽象类比：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java多线程" scheme="http://dumengblog.club/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程—-并行和并发</title>
    <link href="http://dumengblog.club/2019/12/17/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%94-%E4%B8%B2%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91/"/>
    <id>http://dumengblog.club/2019/12/17/java多线程—-串行和并发/</id>
    <published>2019-12-17T03:53:34.000Z</published>
    <updated>2019-12-17T04:04:55.023Z</updated>
    
    <content type="html"><![CDATA[<p>并发和并行的区别：</p><a id="more"></a><p><strong>并发</strong>：一个应用程序如果可以开启多个线程让多个线程同时存在，但是交替执行（比如在单核处理器上）则他称之为并发执行。</p><p><strong>并行</strong>：一个应用程序能并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。</p><p>图解：</p><p><img src="/../asset/image-20191217120358276.png" alt="image-20191217120358276"></p><p><img src="/../asset/image-20191217120324680.png" alt="image-20191217120324680"></p><p><img src="/../asset/image-20191217120339978.png" alt="image-20191217120339978"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发和并行的区别：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java多线程" scheme="http://dumengblog.club/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何输出字符串的所有组合</title>
    <link href="http://dumengblog.club/2019/12/16/%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%80%E6%9C%89%E7%BB%84%E5%90%88/"/>
    <id>http://dumengblog.club/2019/12/16/如何输出字符串的所有组合/</id>
    <published>2019-12-16T11:25:15.000Z</published>
    <updated>2019-12-16T12:24:39.410Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>假设字符串中的所有字符都不重复，如何输出字符串中的所有组合?</p><p>例如输入:</p><p>“abc“，则输出a , b , c , ab , ac , bc , abc 共七种组合。</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>本题可以使用递归方法，遍历字符串，每个字符只能取或不取。若取该字符，就把它放到字符串中，遍历完毕后，输出结果字符串。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 输出字符串的所有组合 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CombineRecursiveImpl</span><span class="params">(<span class="keyword">char</span>[]c,<span class="keyword">int</span> begin,<span class="keyword">int</span> len,StringBuffer sb)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(sb+<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(begin==c.length)&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">sb.append(c[begin]);</span><br><span class="line">CombineRecursiveImpl(c, begin+<span class="number">1</span>, len-<span class="number">1</span>, sb);</span><br><span class="line">sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">CombineRecursiveImpl(c, begin+<span class="number">1</span>, len, sb);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String s=<span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span>[]c=s.toCharArray();</span><br><span class="line">StringBuffer sb=<span class="keyword">new</span> StringBuffer(<span class="string">" "</span>);</span><br><span class="line"><span class="keyword">int</span> len=c.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">CombineRecursiveImpl(c, <span class="number">0</span>, i, sb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何删除字符串中重复的字符</title>
    <link href="http://dumengblog.club/2019/12/16/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6/"/>
    <id>http://dumengblog.club/2019/12/16/如何删除字符串中重复的字符/</id>
    <published>2019-12-16T10:46:15.000Z</published>
    <updated>2019-12-16T11:15:01.138Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>删除字符串中重复的字符，例如“good”去掉重复的字符后就变为god</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2. 解题分析"></a>2. 解题分析</h4><p>新建一个StringBuffer类型字符串，两个while循环，一个用来给StringBuffer添加字符，另一个用来判断是否重复。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何删除字符串中重复的字符 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">removerepeatedchar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line"><span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">sb.append(c);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len &amp;&amp; s.charAt(i) == c) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String s = <span class="string">"aabbb"</span>;</span><br><span class="line">System.out.println(removerepeatedchar(s));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何判断两个字符由相同的字符串组成</title>
    <link href="http://dumengblog.club/2019/12/15/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%94%B1%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%E6%88%90/"/>
    <id>http://dumengblog.club/2019/12/15/如何判断两个字符由相同的字符串组成/</id>
    <published>2019-12-15T13:21:41.000Z</published>
    <updated>2019-12-15T13:26:17.438Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><a id="more"></a><p>由相同的字符组成是指组成两个字符串的字母以及各个字母的个数是一样的，只是排列顺序不同。</p><p>例如 “aba”和“aab”就是相同的数组</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>首先，我们可以将字符串改成byte类型的数组进行排序，然后在进行对比，看是否相等。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何判断两个字符串是否有相同的字符串组成 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">stringIssame</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[]b1 = s1.getBytes();</span><br><span class="line"><span class="keyword">byte</span>[]b2=s2.getBytes();</span><br><span class="line">Arrays.sort(b1);</span><br><span class="line">Arrays.sort(b2);</span><br><span class="line">s1=<span class="keyword">new</span> String(b1);</span><br><span class="line">s2=<span class="keyword">new</span> String(b2);</span><br><span class="line"><span class="keyword">if</span>(s1.equals(s2))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String s1=<span class="string">"aba"</span>;</span><br><span class="line">String s2=<span class="string">"aab"</span>;</span><br><span class="line">System.out.println(stringIssame(s1, s2));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1.问题描述&quot;&gt;&lt;/a&gt;1.问题描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何实现字符串的反转</title>
    <link href="http://dumengblog.club/2019/12/15/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%8D%E8%BD%AC/"/>
    <id>http://dumengblog.club/2019/12/15/如何实现字符串的反转/</id>
    <published>2019-12-15T12:36:58.000Z</published>
    <updated>2019-12-15T12:42:25.988Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><a id="more"></a><p>把一个句子中的单词进行反转</p><p>例如，“how are you”</p><p>进行反转后</p><p>输出“you are how”</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>这道题的解决方法比较简单，只需要进行两次字符反转的操作即可，第1次对整个字符串中的字符进行反转，反转结果为: “uoy era woh”,通过这次的反转已经实现了 单词顺序的反转，只不过每个单词中字符的顺序反了，接下来只需要对每个单词进行字符反转即可得到想要的结果:“you are how”。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何实现字符串的反转 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> []ca,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(begin&lt;end)&#123;</span><br><span class="line"><span class="keyword">char</span> tmp=ca[begin];</span><br><span class="line">ca[begin]=ca[end];</span><br><span class="line">ca[end]=tmp ;</span><br><span class="line">begin++;</span><br><span class="line">end--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseSt</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> []ca=s.toCharArray();</span><br><span class="line">reverse(ca, <span class="number">0</span>, ca.length-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ca.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ca[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">reverse(ca, begin, i-<span class="number">1</span>);</span><br><span class="line">begin=i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于最后一个单词无空格，所以得在循环后再执行一遍字符串反转</span></span><br><span class="line">reverse(ca, begin, ca.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(ca);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str=<span class="keyword">new</span> String(<span class="string">"how are you"</span>);</span><br><span class="line">System.out.println(reverseSt(str));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1.问题描述&quot;&gt;&lt;/a&gt;1.问题描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何判断一个数组中数值是否连续相邻</title>
    <link href="http://dumengblog.club/2019/12/15/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E6%98%AF%E5%90%A6%E8%BF%9E%E7%BB%AD%E7%9B%B8%E9%82%BB/"/>
    <id>http://dumengblog.club/2019/12/15/如何判断一个数组中数值是否连续相邻/</id>
    <published>2019-12-15T12:06:14.000Z</published>
    <updated>2019-12-15T13:54:58.007Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>一个数组序列， 元素取值可能是0 ~ 6535中的任意一个数， 相同数值不会重复出现。0是例外，可以反复出现。设计一种算法，当从该数组序列中随意选取5个数值，判断这5个数值是否连续相邻。需要注意以下4点:</p><p>   1) 5个数值允许是乱序的，例如{8,7,5,0,6}。</p><p>   2) 0可以通配任意数值，例如{8,7,5,0,6 }中的0可以通配成9或者4。</p><p>   3) 0可以多次出现。</p><p>   4)全0算连续，只有一个非0算连续。</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>如果没有0的存在，要组成连续的数列，最大值和最小值的差距必须是4存在0的情况下，只要最大值和最小值的差跟小于4就可以D所以应找出数列中非0的最大值和非0的最小值，时间复杂度为0(n)，如果非0最大-非0最小+1≤≈5 (即非0最大一非0最小&lt;=4)，那么这5个数值连续相邻，否则，不连续相邻。因此，该算法的时间复杂度为0(m)。 </p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何判断一个数组中数值是否相邻 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">iscontinuous</span><span class="params">(<span class="keyword">int</span> []a)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> min=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">max=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;min)&#123;</span><br><span class="line">min=a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(max-min&gt;a.length-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span> []&#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(iscontinuous(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何求数组中两个元素的最小距离</title>
    <link href="http://dumengblog.club/2019/12/12/%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"/>
    <id>http://dumengblog.club/2019/12/12/如何求数组中两个元素的最小距离/</id>
    <published>2019-12-12T03:09:07.000Z</published>
    <updated>2019-12-12T03:20:41.890Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>给定一个数组元素，数组中含有重复元素，给出两个数n1,n2，求这两个数字在数组中所出现位置的最小距离，</p><p>例如：</p><p>数组{4,5,6,7,4,6,4,7,8,5,6,4,3,10,8}中</p><p>4和8的最小距离是：2</p><p>6和7的最小距离是：7</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>首先遍历数组，会遇到以下两种情况：</p><p>1.遇到与n1相等的值，记录下数组下标的位置n1_index,通过n1_index与上次遍历到n2的下标位置n2_index的差，可以求出最近一次遍历到的n1和n2的距离。</p><p>2.遇到与n2相等的值，记录下数组下标的位置n2_index,通过n2_index与上次遍历到n1的下标位置n1_index的差，可以求出最近一次遍历到的n1和n2的距离。</p><p>定义一个变量md记录n1_index和n2_index的最小距离，这样只需遍历一次数组即可求出最小值。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何求数组中两个元素的最小距离 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mindistans</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> n1,<span class="keyword">int</span> n2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">int</span> md=Integer.MIN_VALUE+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n1_index=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n2_index=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==n1)&#123;</span><br><span class="line">n1_index=i;</span><br><span class="line"><span class="keyword">if</span>(n2_index&gt;=<span class="number">0</span>)</span><br><span class="line">md=min(Math.abs(md),Math.abs(n2_index-n1_index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==n2)&#123;</span><br><span class="line">n2_index=i;</span><br><span class="line"><span class="keyword">if</span>(n1_index&gt;=<span class="number">0</span>)</span><br><span class="line">md=min(Math.abs(md),Math.abs(n2_index-n1_index));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> md;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(mindistans(a, <span class="number">3</span>,<span class="number">7</span>));</span><br><span class="line">System.out.println(mindistans(a, <span class="number">6</span>,<span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何求绝对值最小的数</title>
    <link href="http://dumengblog.club/2019/12/11/%E5%A6%82%E4%BD%95%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"/>
    <id>http://dumengblog.club/2019/12/11/如何求绝对值最小的数/</id>
    <published>2019-12-11T11:00:49.000Z</published>
    <updated>2019-12-11T13:19:25.493Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h4><a id="more"></a><p>​        有一个升序排列的数组，数组中可能有正数，负数或0，求数组中元素的绝对值最小的数，例如，数组{-10，-5，-2，-7,  15  ,  50}绝对值最小的是-2</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>​        求数组最小的绝对值，分为三种情况：</p><ol><li><p>数组全是负数绝对值最小的一定是最后一个数</p></li><li><p>数组全是正数即第一个数为非负数，那么绝对值最小的一定是第一个数</p></li><li><p>数组即有正数又有负数时，首先找到正数与负数的分界点，如果分界点恰好为0，那么0就是绝对值最小的数。否则就要通过比较分界点左右的正数和负数的绝对值来确定最小的数。</p><p>那么如何来查找正数与负数的分界点呢?最简单的方法仍然是顺序遍历数组，找出第一个非负数(前提是数组中既有正数又有负数)，接着通过比较分界点两个数的值来找出绝对值最小的数。这种方法在最坏的情况下时间复杂度为0(n)。下面主要介绍采用二分法来查找正数与负数的分界点的方法。其主要思路为:取数组中间位置的值a[ mid]。①a[ mid]=0,那么这个数就是绝对值最小的数;②a[ mid]&gt;0,如果a[mid-1]&lt;0, 那么就找到了分界点，通过比较a[ mid]与a[ mid -1 ]的绝对值就可以找到数组中绝对值最小的数，如果a[ mid -1]=0，那么a[ mid-I]就是要找的数，否则接着在数组的左半部分查找;③a[ mid] &lt;0,如果a[ mid+1]&gt;0,那么通过比较a[mid]与a[ mid +1]的绝对值即可，如果a[ mid+1]=0,那么a[ mid +1]就是要查找的数，否则接着在数组的右半部分继续查找</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何求绝对值最小的数 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinAbsoluteValue</span><span class="params">(<span class="keyword">int</span> []a)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len=a.length;</span><br><span class="line"><span class="keyword">if</span>(len&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[len-<span class="number">1</span>]&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> a[len-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end=len-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> absmin=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[mid-<span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">end=mid-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[mid-<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[mid+<span class="number">1</span>]&lt;<span class="number">0</span>)</span><br><span class="line">start=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[mid+<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;Math.abs(a[mid-<span class="number">1</span>]))</span><br><span class="line">absmin=a[mid];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">absmin=a[mid-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Math.abs(a[mid])&lt;a[mid+<span class="number">1</span>])</span><br><span class="line">absmin=a[mid];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">absmin=a[mid+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> absmin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">10</span>,-<span class="number">5</span>,-<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(getMinAbsoluteValue(a));</span><br><span class="line"><span class="keyword">int</span> []a1=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">System.out.println(getMinAbsoluteValue(a1));</span><br><span class="line"><span class="keyword">int</span> []a2=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">7</span>,-<span class="number">6</span>,-<span class="number">4</span>,-<span class="number">3</span>,-<span class="number">2</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">System.out.println(getMinAbsoluteValue(a2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1.问题描述&quot;&gt;&lt;/a&gt;1.问题描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何用递归求出数组中的最大元素</title>
    <link href="http://dumengblog.club/2019/12/11/%E5%A6%82%E4%BD%95%E7%94%A8%E9%80%92%E5%BD%92%E6%B1%82%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>http://dumengblog.club/2019/12/11/如何用递归求出数组中的最大元素/</id>
    <published>2019-12-11T09:26:16.000Z</published>
    <updated>2019-12-11T09:41:54.589Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>如何用递归求出数组中的最大元素</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>定义一个变量max为数组的第一个元素，然后从第二个元素开始遍历，在遍历过程中，每个元素都与max进行比较，如果大于max则将当前值赋给max。当遍历数组后，最大值也就出来了。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何用递归求出数组中的最大元素 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxnum</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line"><span class="comment">//假如只剩下一个比较的数字</span></span><br><span class="line"><span class="keyword">if</span>(a.length-begin==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> a[begin];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> max(a[begin],maxnum(a, a[begin+<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(maxnum(a, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何找出数组中只出现一次的数字</title>
    <link href="http://dumengblog.club/2019/12/11/%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://dumengblog.club/2019/12/11/如何找出数组中只出现一次的数字/</id>
    <published>2019-12-11T09:01:18.000Z</published>
    <updated>2019-12-11T09:25:01.562Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>一个整形数组里除了一个数字外，其他数字都出现两次。找出这个只出现一次的数字</p><p>例如：</p><p>数组：{2,2,1,3,4,3,4}</p><p>输出：1</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>这里可以用异或这个符号：“^”,如果两个相同的数字进行异或结果为零，如果0和当前数字进行异或，则结果还为当前数字，所以我们从头遍历数组，对每个数字进行异或操作，最终剩下的就是只出现一次的数字。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何找出数组中只出现一次的数字 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNotDouble</span><span class="params">(<span class="keyword">int</span> []a)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">result^=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[]a=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(findNotDouble(a));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何把一个数组循环右移K位</title>
    <link href="http://dumengblog.club/2019/12/10/%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BBK%E4%BD%8D/"/>
    <id>http://dumengblog.club/2019/12/10/如何把一个数组循环右移K位/</id>
    <published>2019-12-10T13:01:22.000Z</published>
    <updated>2019-12-10T13:15:29.916Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>把数组序列[1,2,3,4,5,6,7,8]右移两位变为[7, 8, 1, 2, 3, 4, 5, 6]</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>首先将数组分为两段数组序列：</p><p>[1, 2, 3, 4, 5, 6]</p><p>[7, 8]</p><ol><li><p>首先先将第一段数组序列反转</p><p>[6，5，4，3，2，1，7，8]</p></li><li><p>再将第二段数组序列反转</p><p>[6，5，4，3，2，1，8,   7]</p></li><li><p>再将整个数组反转即得到结果</p><p>[7, 8, 1, 2, 3, 4, 5, 6]</p></li></ol><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 如何把一个数组循环右移<span class="title">K</span>位 </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[]a ,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(begin&lt;end)&#123;</span><br><span class="line"><span class="keyword">int</span> tmp=a[begin];</span><br><span class="line">a[begin]=a[end];</span><br><span class="line">a[end]=tmp;</span><br><span class="line">begin++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftK</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=a.length;</span><br><span class="line">k=k%n;</span><br><span class="line">reverse(a, n-k, n-<span class="number">1</span>);</span><br><span class="line">reverse(a,<span class="number">0</span>,n-k-<span class="number">1</span>);</span><br><span class="line">reverse(a,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">shiftK(a, <span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何求数组中两两相加等于max的组合种数</title>
    <link href="http://dumengblog.club/2019/12/10/%E5%A6%82%E4%BD%95%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%A4%E7%9B%B8%E5%8A%A0%E7%AD%89%E4%BA%8E20%E7%9A%84%E7%BB%84%E5%90%88%E7%A7%8D%E6%95%B0/"/>
    <id>http://dumengblog.club/2019/12/10/如何求数组中两两相加等于20的组合种数/</id>
    <published>2019-12-10T12:13:42.000Z</published>
    <updated>2019-12-10T12:31:51.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h4><a id="more"></a><p>给定一个数组[7,3,4,8,1], max=9 </p><p>这个数组中满足条件的组合为8,1</p><p>则输出 8,1</p><h4 id="2-问题解析"><a href="#2-问题解析" class="headerlink" title="2.问题解析"></a>2.问题解析</h4><p>方法1：“蛮力”法</p><p>两重循环判断两个数的和是否为max，时间复杂度为O(n²)</p><p>方法2：排序法</p><p>先对数组元素进行排序，此算法的时间复杂度为O(nlogn)，对排序后的数组分别从前到后和从后向前遍历，当满足a[start]+a[end]&gt;max ，如果存在两个数的和等于max则一定在[start,end+1]之间，当满足a[start]+a[end]&lt;max ，如果存在两个数的和等于max则一定在[start+1,end]之间.</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 求数组中两两相加等于20的组合种数 </span>&#123;</span><br><span class="line"><span class="comment">//蛮力法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findSumNumber</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;a.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]+a[j]==max)&#123;</span><br><span class="line"><span class="keyword">return</span> a[i]+<span class="string">" "</span>+a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findSumNumber1</span><span class="params">(<span class="keyword">int</span> []a,<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end=a.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[start]+a[end]&gt;max)&#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[start]+a[end]&lt;max)&#123;</span><br><span class="line">start++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(a[start]+<span class="string">" "</span>+a[end]);</span><br><span class="line">start++;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> []a=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">System.out.println(findSumNumber(a, <span class="number">9</span>));</span><br><span class="line">findSumNumber1(a, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-问题描述&quot;&gt;&lt;a href=&quot;#1-问题描述&quot; class=&quot;headerlink&quot; title=&quot;1. 问题描述&quot;&gt;&lt;/a&gt;1. 问题描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode5_最长回文串</title>
    <link href="http://dumengblog.club/2019/12/10/leetcode5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://dumengblog.club/2019/12/10/leetcode5-最长回文串/</id>
    <published>2019-12-10T05:47:40.000Z</published>
    <updated>2019-12-10T06:01:25.380Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p><p>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>首先这里需要利用substring（）这个方法</p><p> substring() 方法返回字符串的子字符串。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex, int endIndex)</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p><strong>beginIndex</strong> – 起始索引（包括）, 索引从 0 开始。</p></li><li><p><strong>endIndex</strong> – 结束索引（不包括）。</p></li></ul><p>首先一个回文数，是分偶数和奇数的。</p><p>例如：</p><p>偶数：bbcc</p><p>奇数：aba</p><p>所以我们在这里用到的是<strong>中心扩散法</strong>，假如回文数是奇数，则以自己为中心两边向外扩散，同时判断新加的两个数是否相等，而偶数就要先判断两边的数字是否相等。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution4</span> </span>&#123;</span><br><span class="line">String res=<span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        expandAroundCenter(s, i, i);</span><br><span class="line">        expandAroundCenter(s, i, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">    left--;</span><br><span class="line">    right++;</span><br><span class="line">    &#125;</span><br><span class="line">    String cur=s.substring(left+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">if</span>(cur.length()&gt;res.length())&#123;</span><br><span class="line">    res=cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode4_寻找两个有序数组的中位数</title>
    <link href="http://dumengblog.club/2019/12/09/leetcode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://dumengblog.club/2019/12/09/leetcode4-寻找两个有序数组的中位数/</id>
    <published>2019-12-09T14:06:30.000Z</published>
    <updated>2019-12-09T14:20:31.206Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><blockquote><p>示例1:</p><p>nums1 = [1, 3]<br> nums2 = [2]</p><p>则中位数是 2.0</p></blockquote><blockquote><p>示例2:</p><p>nums1 = [1, 2]<br> nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p></blockquote><h4 id="2-解题分析"><a href="#2-解题分析" class="headerlink" title="2.解题分析"></a>2.解题分析</h4><p>先从题干进行分析 , 本题若没有时间复杂度要求,将是一道极简单的题.</p><p>我们可以先将两个数组合并,再排序 ,以此完成解题.</p><p>本题给出的时间复杂度为 O(log(m + n)) , 由此我们想到<strong>二分查找</strong>,事实也确乎如此.</p><p>下面开始分析问题,先从中位数的作用入手</p><p> <strong>中位数</strong> : 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 </p><p>对本题而言,我们要做的就是把有序数组A,B进行分割,共分为四个子数组,分别记作left_A,left_B,left_A,right_A.</p><p>将left_A和left_B合并记作left_part,</p><p>同理,得到right_part.</p><p>如果我们可以确认:</p><blockquote><ol><li>len(left_part) = len(right_part)</li><li>max(left_part) ≤ min(right_part)</li></ol></blockquote><p>那么,我们就得到了两个长度相同的部分,且其中一部分的元素总是大于或等于另一部分的元素.</p><p>到这里,我们就已经很接近答案了.</p><p>要满足上面的两个条件,我们只需要保证：</p><p><img src="/../asset/14927224-1ba888260ba02871.png" alt="14927224-1ba888260ba02871"></p><p><strong>注意:</strong> 其中<code>1</code>中的 m - i + n - j + 1的 <code>&quot;+1&quot;</code>的原因是存由于在奇偶的差别.</p><p>从<code>1</code>中我们可以看出,j 可以被 i 表示,所以,接下来的问题变为:</p><p><strong>找到满足<code>2</code>的 i</strong></p><p>对此,我们可以使用二分查找(<em>具体查找的过程,以及临界分析写在下面注释中</em>)</p><p>当找到目标对象 i 后 , 中位数为 :</p><p><img src="/../asset/14927224-d7f3cf5caf331963-1575901137870.png" alt="14927224-d7f3cf5caf331963"></p><h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="comment">// 保证num1的长度总是小于或等于nums2</span></span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = nums1;nums1 = nums2; nums2 = temp;</span><br><span class="line">            <span class="keyword">int</span> lengthTemp = m; m = n; n = lengthTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> imax = m,imin = <span class="number">0</span>,half = (m+n+<span class="number">1</span>)/<span class="number">2</span> ;</span><br><span class="line">        <span class="comment">//开始查找</span></span><br><span class="line">        <span class="keyword">while</span>(imax &gt;= imin)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = (imax+imin)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = half - i;</span><br><span class="line">            <span class="comment">// i 过小且i可以再增大</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;imax &amp;&amp; nums2[j-<span class="number">1</span>]&gt;nums1[i])&#123;</span><br><span class="line">                imin = i +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i 过大且i可以再减小</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;imin &amp;&amp; nums1[i-<span class="number">1</span>]&gt;nums2[j])&#123;</span><br><span class="line">                imax = i -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> leftmax = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// left_num1为空时</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;leftmax = nums2[j-<span class="number">1</span>];&#125;</span><br><span class="line">                <span class="comment">// left_num2为空时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123; leftmax = nums1[i-<span class="number">1</span>];&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;leftmax = Math.max(nums1[i-<span class="number">1</span>],nums2[j-<span class="number">1</span>]);&#125;</span><br><span class="line">                <span class="comment">// 当m+n 为奇数时,返回奇数解</span></span><br><span class="line">                <span class="keyword">if</span>((m+n)%<span class="number">2</span> == <span class="number">1</span>)  <span class="keyword">return</span> leftmax;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> rightmin = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// right_num1为空时</span></span><br><span class="line">                <span class="keyword">if</span>(i == m)&#123; rightmin = nums2[j];&#125;</span><br><span class="line">                <span class="comment">// right_num2为空时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == n) &#123;rightmin = nums1[i];&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; rightmin = Math.min(nums1[i],nums2[j]);&#125;</span><br><span class="line">                <span class="comment">// 当m+n 为偶数时,返回偶数解</span></span><br><span class="line">                <span class="keyword">return</span> (leftmax+rightmin)/<span class="number">2.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode3_无重复字符的最长子串</title>
    <link href="http://dumengblog.club/2019/12/09/leetcode3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://dumengblog.club/2019/12/09/leetcode3-无重复字符的最长子串/</id>
    <published>2019-12-09T12:54:17.000Z</published>
    <updated>2019-12-09T13:22:31.986Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h4 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h4><p> 定义两个指针，start和end，代表当前窗口的开始和结束位置，同样使用hashset,当窗口中出现重复的字符时，start++,没有重复时，end++,每次更新长度的最大值 </p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>,start=<span class="number">0</span>;</span><br><span class="line">    Set&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(start&lt;n &amp;&amp; end&lt;n)&#123;</span><br><span class="line">      <span class="keyword">if</span>(set.contains(s.charAt(end)))&#123;</span><br><span class="line">       set.remove(s.charAt(start++));</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        set.add(s.charAt(end++));</span><br><span class="line">        res=Math.max(res,end-start);</span><br><span class="line">      &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode2_两数相加</title>
    <link href="http://dumengblog.club/2019/12/09/leetcode2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://dumengblog.club/2019/12/09/leetcode2-两数相加/</id>
    <published>2019-12-09T12:41:38.000Z</published>
    <updated>2019-12-09T12:50:41.227Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><a id="more"></a><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><h4 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h4><p>其实本题，远比看着简单许多，就是两个链表相加的意思,首先新建一个链表，将传入的两个链表的第一个值相加，赋给新建的链表头结点的下一个节点，然后再循环这个过程直到两个链表为空，返回新建链表头结点的下一个节点。</p><h4 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode n=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    ListNode cur=n;</span><br><span class="line">    ListNode p1=l1,p2=l2;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="keyword">null</span>||p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    sum+=p1.val;</span><br><span class="line">    p1=p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    sum+=p2.val;</span><br><span class="line">    p2=p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">    sum/=<span class="number">10</span>;</span><br><span class="line">    cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">1</span>)&#123;</span><br><span class="line">    cur.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.题目描述&quot;&gt;&lt;/a&gt;1.题目描述&lt;/h4&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode1_两数之和</title>
    <link href="http://dumengblog.club/2019/12/09/leetcode-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://dumengblog.club/2019/12/09/leetcode-两数之和/</id>
    <published>2019-12-09T01:15:01.000Z</published>
    <updated>2019-12-09T01:38:12.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><a id="more"></a><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h3><p>个人本次利用了Hashmap来解决这道题，首先由于返回一个数组，所以要在方法体新建一个数组，并且返回这个数组，首先对传进来的数组进行判断是否为空。然后对数组遍历，一边把数据存储在hashmap里，key存数组的值，value存数组的下标。一边查询target减当前数组的值，如果查询到了，则将i放在新建的数组中，另一个就是找到的另一个值的下标。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[]res=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>&amp;&amp;nums.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num=nums[i];</span><br><span class="line">            <span class="keyword">int</span> val=target-num;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(val))&#123;</span><br><span class="line">            res[<span class="number">0</span>]=i;</span><br><span class="line">            res[<span class="number">1</span>]=map.get(val);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(num, i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-题目描述&quot;&gt;&lt;a href=&quot;#1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1. 题目描述&quot;&gt;&lt;/a&gt;1. 题目描述&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://dumengblog.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
